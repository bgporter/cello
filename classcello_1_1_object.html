<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cello: cello::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="cello_cello.png"/></td>
  <td id="projectalign">
   <div id="projectname">cello
   </div>
   <div id="projectbrief">JUCE ValueTrees for Humans</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcello_1_1_object.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcello_1_1_object-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cello::Object Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for cello::Object:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcello_1_1_object.png" usemap="#cello::Object_map" alt=""/>
  <map id="cello::Object_map" name="cello::Object_map">
<area href="classcello_1_1_update_source.html" alt="cello::UpdateSource" shape="rect" coords="169,0,328,24"/>
<area href="class_object_with_area.html" alt="ObjectWithArea" shape="rect" coords="0,112,159,136"/>
<area href="class_object_with_conversion.html" alt="ObjectWithConversion" shape="rect" coords="169,112,328,136"/>
<area href="structcello_1_1_ipc_client_properties.html" title="Properties struct to monitor an IPC client. Created automatically when creating an IpcClient object,..." alt="cello::IpcClientProperties" shape="rect" coords="338,112,497,136"/>
<area href="structcello_1_1_ipc_server_properties.html" alt="cello::IpcServerProperties" shape="rect" coords="507,112,666,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae42a337f7e71e31594fbdddc64b14bc4" id="r_ae42a337f7e71e31594fbdddc64b14bc4"><td class="memItemLeft" align="right" valign="top"><a id="ae42a337f7e71e31594fbdddc64b14bc4" name="ae42a337f7e71e31594fbdddc64b14bc4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>FileFormat</b> { <b>xml</b>
, <b>binary</b>
, <b>zipped</b>
 }</td></tr>
<tr class="separator:ae42a337f7e71e31594fbdddc64b14bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2be639aa87106819668b8b8a9a434b" id="r_aee2be639aa87106819668b8b8a9a434b"><td class="memItemLeft" align="right" valign="top"><a id="aee2be639aa87106819668b8b8a9a434b" name="aee2be639aa87106819668b8b8a9a434b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>CreationType</b> { <b>initialized</b>
, <b>wrapped</b>
 }</td></tr>
<tr class="separator:aee2be639aa87106819668b8b8a9a434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e0aab983b0079b72a5cc652ef06e775" id="r_a4e0aab983b0079b72a5cc652ef06e775"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0aab983b0079b72a5cc652ef06e775">Object</a> (const juce::String &amp;type, const <a class="el" href="classcello_1_1_object.html">Object</a> *state)</td></tr>
<tr class="memdesc:a4e0aab983b0079b72a5cc652ef06e775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcello_1_1_object.html">cello::Object</a> object, which will attempt to initialize from the 'state' parameter. If 'state' contains a ValueTree of the requested type, we'll use that as our store.  <br /></td></tr>
<tr class="separator:a4e0aab983b0079b72a5cc652ef06e775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a891dc061e42fafeacbe0a2aa01607" id="r_a63a891dc061e42fafeacbe0a2aa01607"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a891dc061e42fafeacbe0a2aa01607">Object</a> (const juce::String &amp;type, const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;state)</td></tr>
<tr class="memdesc:a63a891dc061e42fafeacbe0a2aa01607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcello_1_1_object.html">Object</a>, initializing from the <code>state</code> argument. Follows the same descent logic used in the above constructor.  <br /></td></tr>
<tr class="separator:a63a891dc061e42fafeacbe0a2aa01607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d80db10512c4cfa708543ccf83e3428" id="r_a3d80db10512c4cfa708543ccf83e3428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d80db10512c4cfa708543ccf83e3428">Object</a> (const juce::String &amp;type, juce::ValueTree tree)</td></tr>
<tr class="memdesc:a3d80db10512c4cfa708543ccf83e3428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> from a raw juce ValueTree. Its behavior mimics that of the ctor that accepts a pointer to object, attempting to either:  <br /></td></tr>
<tr class="separator:a3d80db10512c4cfa708543ccf83e3428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a186ba097370a8a778be2314c37d6c" id="r_a11a186ba097370a8a778be2314c37d6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11a186ba097370a8a778be2314c37d6c">Object</a> (const juce::String &amp;type, juce::File file, FileFormat format=FileFormat::xml)</td></tr>
<tr class="memdesc:a11a186ba097370a8a778be2314c37d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> by attempting to load it from a file on disk. You can test whether this succeeded by checking the return value of <code><a class="el" href="#ae04aa9d628d2ee279d9d467c8caf73d8" title="Determine how this object was created, which will be one of:">getCreationType()</a></code> &ndash; if its value is <code>CreationType::initialized</code>, the load from disk failed, and this instance was default-initialized.  <br /></td></tr>
<tr class="separator:a11a186ba097370a8a778be2314c37d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d5d0df3615b3a6a294929d16fd90ce" id="r_ad0d5d0df3615b3a6a294929d16fd90ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d5d0df3615b3a6a294929d16fd90ce">Object</a> (const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad0d5d0df3615b3a6a294929d16fd90ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> object as a copy of an existing one. We register as a listener, but this new copy does not have any callbacks registered. Both objects will point at the same shared value tree.  <br /></td></tr>
<tr class="separator:ad0d5d0df3615b3a6a294929d16fd90ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41128bc9a0e36952a2ea053d332455e2" id="r_a41128bc9a0e36952a2ea053d332455e2"><td class="memItemLeft" align="right" valign="top">CreationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41128bc9a0e36952a2ea053d332455e2">wrap</a> (const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;other)</td></tr>
<tr class="memdesc:a41128bc9a0e36952a2ea053d332455e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap another <a class="el" href="classcello_1_1_object.html">Object</a>'s tree after this object is created.  <br /></td></tr>
<tr class="separator:a41128bc9a0e36952a2ea053d332455e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43381ba2a3be680f308b6d1bfc284e3" id="r_ad43381ba2a3be680f308b6d1bfc284e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcello_1_1_object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad43381ba2a3be680f308b6d1bfc284e3">operator=</a> (const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad43381ba2a3be680f308b6d1bfc284e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set this object to use a different <a class="el" href="classcello_1_1_object.html">Object</a>'s value tree, which we will begin listening to. Our <code>valueTreeRedirected</code> callback should be executed.  <br /></td></tr>
<tr class="separator:ad43381ba2a3be680f308b6d1bfc284e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c001271075ceb3006e2fed75aef279" id="r_a34c001271075ceb3006e2fed75aef279"><td class="memItemLeft" align="right" valign="top"><a id="a34c001271075ceb3006e2fed75aef279" name="a34c001271075ceb3006e2fed75aef279"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Object</b> () override</td></tr>
<tr class="memdesc:a34c001271075ceb3006e2fed75aef279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classcello_1_1_object.html">Object</a> object The important thing done here is to remove ourselves as a listener to the value tree we're attached to. <br /></td></tr>
<tr class="separator:a34c001271075ceb3006e2fed75aef279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fabc22c50460fc720c8be1c3384db70" id="r_a3fabc22c50460fc720c8be1c3384db70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fabc22c50460fc720c8be1c3384db70">operator==</a> (const juce::ValueTree &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a3fabc22c50460fc720c8be1c3384db70"><td class="mdescLeft">&#160;</td><td class="mdescRight">test for true equivalence: does this object point to the same underlying tree as the tree on the right hand side? Note that because <a class="el" href="classcello_1_1_object.html">cello::Object</a> has <code>operator juce::ValueTree</code>, you can pass a reference to <a class="el" href="classcello_1_1_object.html">Object</a> as the rhs and it will work correctly.  <br /></td></tr>
<tr class="separator:a3fabc22c50460fc720c8be1c3384db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b078ff990b5976ae37cbb44b3d9f91d" id="r_a1b078ff990b5976ae37cbb44b3d9f91d"><td class="memItemLeft" align="right" valign="top"><a id="a1b078ff990b5976ae37cbb44b3d9f91d" name="a1b078ff990b5976ae37cbb44b3d9f91d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const juce::ValueTree &amp;rhs) const noexcept</td></tr>
<tr class="separator:a1b078ff990b5976ae37cbb44b3d9f91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365e8cc11d3d6ea98957cf150450b1a" id="r_a9365e8cc11d3d6ea98957cf150450b1a"><td class="memItemLeft" align="right" valign="top">juce::Identifier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9365e8cc11d3d6ea98957cf150450b1a">getType</a> () const</td></tr>
<tr class="memdesc:a9365e8cc11d3d6ea98957cf150450b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of this object as a juce::Identifier.  <br /></td></tr>
<tr class="separator:a9365e8cc11d3d6ea98957cf150450b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c7f790afc2b708da43601d00f38cf" id="r_a007c7f790afc2b708da43601d00f38cf"><td class="memItemLeft" align="right" valign="top">juce::String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007c7f790afc2b708da43601d00f38cf">getTypeName</a> () const</td></tr>
<tr class="memdesc:a007c7f790afc2b708da43601d00f38cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of this object as a string.  <br /></td></tr>
<tr class="separator:a007c7f790afc2b708da43601d00f38cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb33870b81e819ffa3e6d598a7eefffb" id="r_aeb33870b81e819ffa3e6d598a7eefffb"><td class="memItemLeft" align="right" valign="top">juce::String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb33870b81e819ffa3e6d598a7eefffb">toXmlString</a> (const juce::XmlElement::TextFormat &amp;format={}) const</td></tr>
<tr class="memdesc:aeb33870b81e819ffa3e6d598a7eefffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of this object's tree.  <br /></td></tr>
<tr class="separator:aeb33870b81e819ffa3e6d598a7eefffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04aa9d628d2ee279d9d467c8caf73d8" id="r_ae04aa9d628d2ee279d9d467c8caf73d8"><td class="memItemLeft" align="right" valign="top">CreationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae04aa9d628d2ee279d9d467c8caf73d8">getCreationType</a> () const</td></tr>
<tr class="memdesc:ae04aa9d628d2ee279d9d467c8caf73d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how this object was created, which will be one of:  <br /></td></tr>
<tr class="separator:ae04aa9d628d2ee279d9d467c8caf73d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55254d40c64fc95eb3b4a774b8d406b2" id="r_a55254d40c64fc95eb3b4a774b8d406b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55254d40c64fc95eb3b4a774b8d406b2">wasWrapped</a> () const</td></tr>
<tr class="memdesc:a55254d40c64fc95eb3b4a774b8d406b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility method to test the creation type as a bool.  <br /></td></tr>
<tr class="separator:a55254d40c64fc95eb3b4a774b8d406b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e737e33370e4f888052cca6a2c90cc" id="r_a42e737e33370e4f888052cca6a2c90cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e737e33370e4f888052cca6a2c90cc">wasInitialized</a> () const</td></tr>
<tr class="memdesc:a42e737e33370e4f888052cca6a2c90cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility method to test the creation type as a bool.  <br /></td></tr>
<tr class="separator:a42e737e33370e4f888052cca6a2c90cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9527be361c6013e97bda636a549d6e" id="r_aab9527be361c6013e97bda636a549d6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab9527be361c6013e97bda636a549d6e">operator juce::ValueTree</a> () const</td></tr>
<tr class="memdesc:aab9527be361c6013e97bda636a549d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ValueTree we're using as our data store.  <br /></td></tr>
<tr class="separator:aab9527be361c6013e97bda636a549d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62394b84057f6fce787bc8cf61c4facb" id="r_a62394b84057f6fce787bc8cf61c4facb"><td class="memItemLeft" align="right" valign="top">juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62394b84057f6fce787bc8cf61c4facb">clone</a> (bool deep) const</td></tr>
<tr class="memdesc:a62394b84057f6fce787bc8cf61c4facb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make and return a copy of our underlying value tree.  <br /></td></tr>
<tr class="separator:a62394b84057f6fce787bc8cf61c4facb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef5e5b7d054ac2ab811cde202b27889" id="r_abef5e5b7d054ac2ab811cde202b27889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abef5e5b7d054ac2ab811cde202b27889">update</a> (const juce::MemoryBlock &amp;updateBlock)</td></tr>
<tr class="memdesc:abef5e5b7d054ac2ab811cde202b27889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply delta/update generated by the juce::ValueTreeSynchroniser class; this is used in the sync and ipc implementations.  <br /></td></tr>
<tr class="separator:abef5e5b7d054ac2ab811cde202b27889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25ab25ee62b03dda46143a20054c02" id="r_a4b25ab25ee62b03dda46143a20054c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b25ab25ee62b03dda46143a20054c02">excludeListener</a> (juce::ValueTree::Listener *listener)</td></tr>
<tr class="memdesc:a4b25ab25ee62b03dda46143a20054c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A listener to exclude from property change updates.  <br /></td></tr>
<tr class="separator:a4b25ab25ee62b03dda46143a20054c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36491bac36514cc7e88454d8444d0a0f" id="r_a36491bac36514cc7e88454d8444d0a0f"><td class="memItemLeft" align="right" valign="top">juce::ValueTree::Listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36491bac36514cc7e88454d8444d0a0f">getExcludedListener</a> () const</td></tr>
<tr class="memdesc:a36491bac36514cc7e88454d8444d0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the listener to exclude from property change updates.  <br /></td></tr>
<tr class="separator:a36491bac36514cc7e88454d8444d0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Database functionality</div></td></tr>
<tr class="memitem:aa28a19ff0e4f6e6c826e7293e1937d23" id="r_aa28a19ff0e4f6e6c826e7293e1937d23"><td class="memItemLeft" align="right" valign="top">juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28a19ff0e4f6e6c826e7293e1937d23">find</a> (const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;query, bool deep=false)</td></tr>
<tr class="memdesc:aa28a19ff0e4f6e6c826e7293e1937d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a query against the children of this <a class="el" href="classcello_1_1_object.html">Object</a>, returning a new ValueTree containing zero or more copies of child trees that match the query, possibly sorted into a different order than they exist in this tree.  <br /></td></tr>
<tr class="separator:aa28a19ff0e4f6e6c826e7293e1937d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7230b2a5bdaedf19fd3b6487e40138f" id="r_aa7230b2a5bdaedf19fd3b6487e40138f"><td class="memItemLeft" align="right" valign="top">juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7230b2a5bdaedf19fd3b6487e40138f">findOne</a> (const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;query, bool deep=false)</td></tr>
<tr class="memdesc:aa7230b2a5bdaedf19fd3b6487e40138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a query against the children of this object, returning a copy of the first child found that meets the predicates in the query object, or an empty tree if none is found.  <br /></td></tr>
<tr class="separator:aa7230b2a5bdaedf19fd3b6487e40138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cc2848d284422f9fa6ae24fc7f7ed6" id="r_a43cc2848d284422f9fa6ae24fc7f7ed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43cc2848d284422f9fa6ae24fc7f7ed6">remove</a> (const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;query)</td></tr>
<tr class="memdesc:a43cc2848d284422f9fa6ae24fc7f7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all children from the tree that match the query.  <br /></td></tr>
<tr class="separator:a43cc2848d284422f9fa6ae24fc7f7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a8d3a310c6ac67498f762224f09daf" id="r_a26a8d3a310c6ac67498f762224f09daf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26a8d3a310c6ac67498f762224f09daf">upsert</a> (const <a class="el" href="classcello_1_1_object.html">Object</a> *object, const juce::Identifier &amp;key, bool deep=false)</td></tr>
<tr class="memdesc:a26a8d3a310c6ac67498f762224f09daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update or insert a child object (concept borrowed from MongoDB) Looks for a child with a 'key' value that matches the one found in the object we've been passed. If a match is found, we update the entry in place (update). If no match is found, we append a copy of <code>object</code> to our children.  <br /></td></tr>
<tr class="separator:a26a8d3a310c6ac67498f762224f09daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f3e07c7db1d4d8af104d9ea5c63883" id="r_ae4f3e07c7db1d4d8af104d9ea5c63883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f3e07c7db1d4d8af104d9ea5c63883">upsertAll</a> (const <a class="el" href="classcello_1_1_object.html">Object</a> *parent, const juce::Identifier &amp;key, bool deep=false)</td></tr>
<tr class="memdesc:ae4f3e07c7db1d4d8af104d9ea5c63883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an upsert using each of the children of the parent being passed. Common workflow here:  <br /></td></tr>
<tr class="separator:ae4f3e07c7db1d4d8af104d9ea5c63883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Undo/redo functionality</div></td></tr>
<tr class="memitem:a14e852dd0a299e2d72bf07dd8970b52a" id="r_a14e852dd0a299e2d72bf07dd8970b52a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14e852dd0a299e2d72bf07dd8970b52a">setUndoManager</a> (juce::UndoManager *<a class="el" href="#a9068e0306934dcbf2c24b71efe5c1024">undo</a>)</td></tr>
<tr class="memdesc:a14e852dd0a299e2d72bf07dd8970b52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the undo manager to use in this object (and others created from it).  <br /></td></tr>
<tr class="separator:a14e852dd0a299e2d72bf07dd8970b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19bde9dc0f5ae807641414d8e890d44" id="r_aa19bde9dc0f5ae807641414d8e890d44"><td class="memItemLeft" align="right" valign="top">juce::UndoManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa19bde9dc0f5ae807641414d8e890d44">getUndoManager</a> () const</td></tr>
<tr class="memdesc:aa19bde9dc0f5ae807641414d8e890d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current undo manager; only useful to this object's <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">Value</a> objects and when creating other Objects to wrap our subtrees.  <br /></td></tr>
<tr class="separator:aa19bde9dc0f5ae807641414d8e890d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cace96ea91fd79dfc17cb44b9c4fbf9" id="r_a6cace96ea91fd79dfc17cb44b9c4fbf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cace96ea91fd79dfc17cb44b9c4fbf9">canUndo</a> () const</td></tr>
<tr class="memdesc:a6cace96ea91fd79dfc17cb44b9c4fbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object/tree has anything that can be undone.  <br /></td></tr>
<tr class="separator:a6cace96ea91fd79dfc17cb44b9c4fbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9068e0306934dcbf2c24b71efe5c1024" id="r_a9068e0306934dcbf2c24b71efe5c1024"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9068e0306934dcbf2c24b71efe5c1024">undo</a> ()</td></tr>
<tr class="memdesc:a9068e0306934dcbf2c24b71efe5c1024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to undo the last transaction.  <br /></td></tr>
<tr class="separator:a9068e0306934dcbf2c24b71efe5c1024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887fbb6f22d47fc6e2cdfec57c320efe" id="r_a887fbb6f22d47fc6e2cdfec57c320efe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887fbb6f22d47fc6e2cdfec57c320efe">canRedo</a> () const</td></tr>
<tr class="memdesc:a887fbb6f22d47fc6e2cdfec57c320efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object/tree has anything that can be redone.  <br /></td></tr>
<tr class="separator:a887fbb6f22d47fc6e2cdfec57c320efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534edaa253affc488dba210e86e55ccf" id="r_a534edaa253affc488dba210e86e55ccf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a534edaa253affc488dba210e86e55ccf">redo</a> ()</td></tr>
<tr class="memdesc:a534edaa253affc488dba210e86e55ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to redo the last transaction.  <br /></td></tr>
<tr class="separator:a534edaa253affc488dba210e86e55ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd126a66992806eca5aaecea0d5f71d1" id="r_abd126a66992806eca5aaecea0d5f71d1"><td class="memItemLeft" align="right" valign="top"><a id="abd126a66992806eca5aaecea0d5f71d1" name="abd126a66992806eca5aaecea0d5f71d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearUndoHistory</b> ()</td></tr>
<tr class="memdesc:abd126a66992806eca5aaecea0d5f71d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the undo manager <br /></td></tr>
<tr class="separator:abd126a66992806eca5aaecea0d5f71d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pythonesque access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>We use names (ending in <code>-attr</code>) borrowed from Python for this set of functions to make them stand out. When using these, the <a class="el" href="classcello_1_1_object.html">Object</a> becomes more dynamically typed; the type-safety provided by working through * the <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a> class is bypassed, and you can add/remove attributes/properties and change their types from the object at runtime as is useful for you. </p>
</div></td></tr>
<tr class="memitem:a6a23c8172d0df906594e9d222dd6e441" id="r_a6a23c8172d0df906594e9d222dd6e441"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6a23c8172d0df906594e9d222dd6e441"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a23c8172d0df906594e9d222dd6e441">getattr</a> (const juce::Identifier &amp;attr, const T &amp;defaultVal) const</td></tr>
<tr class="memdesc:a6a23c8172d0df906594e9d222dd6e441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property value from this object, or default if it doesn't have a property with that name.  <br /></td></tr>
<tr class="separator:a6a23c8172d0df906594e9d222dd6e441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556d736691db1d05b208a8b3c6f58ebd" id="r_a556d736691db1d05b208a8b3c6f58ebd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556d736691db1d05b208a8b3c6f58ebd">hasattr</a> (const juce::Identifier &amp;attr) const</td></tr>
<tr class="memdesc:a556d736691db1d05b208a8b3c6f58ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the object to see if it has an attribute with this id.  <br /></td></tr>
<tr class="separator:a556d736691db1d05b208a8b3c6f58ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39df4cb5bd79fd770ad23184d5ef8c87" id="r_a39df4cb5bd79fd770ad23184d5ef8c87"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a39df4cb5bd79fd770ad23184d5ef8c87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcello_1_1_object.html">Object</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39df4cb5bd79fd770ad23184d5ef8c87">setattr</a> (const juce::Identifier &amp;attr, const T &amp;attrVal)</td></tr>
<tr class="memdesc:a39df4cb5bd79fd770ad23184d5ef8c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new value for the specified attribute/property. We return a reference to this object so that setattr calls may be chained.  <br /></td></tr>
<tr class="separator:a39df4cb5bd79fd770ad23184d5ef8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd4f6b747c7c120ded85f09765378af" id="r_a7fd4f6b747c7c120ded85f09765378af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fd4f6b747c7c120ded85f09765378af">delattr</a> (const juce::Identifier &amp;attr)</td></tr>
<tr class="memdesc:a7fd4f6b747c7c120ded85f09765378af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified property from this object.  <br /></td></tr>
<tr class="separator:a7fd4f6b747c7c120ded85f09765378af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcello_1_1_update_source"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classcello_1_1_update_source')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcello_1_1_update_source.html">cello::UpdateSource</a></td></tr>
<tr class="memitem:a776d44ec037a4cbbc8631118fa5876ca inherit pub_methods_classcello_1_1_update_source" id="r_a776d44ec037a4cbbc8631118fa5876ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcello_1_1_update_source.html#a776d44ec037a4cbbc8631118fa5876ca">forceUpdate</a> (bool <a class="el" href="classcello_1_1_update_source.html#ad5c26a9a373b1a3efb06d9d134664d59">shouldForceUpdate</a>)</td></tr>
<tr class="memdesc:a776d44ec037a4cbbc8631118fa5876ca inherit pub_methods_classcello_1_1_update_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">If passed true, any call that sets any <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">Value</a> property on this <a class="el" href="classcello_1_1_object.html">Object</a> will result in a property change update callback being executed. Default (false) behavior only performs this callback when the underlying value is changed.  <br /></td></tr>
<tr class="separator:a776d44ec037a4cbbc8631118fa5876ca inherit pub_methods_classcello_1_1_update_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c26a9a373b1a3efb06d9d134664d59 inherit pub_methods_classcello_1_1_update_source" id="r_ad5c26a9a373b1a3efb06d9d134664d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcello_1_1_update_source.html#ad5c26a9a373b1a3efb06d9d134664d59">shouldForceUpdate</a> () const</td></tr>
<tr class="separator:ad5c26a9a373b1a3efb06d9d134664d59 inherit pub_methods_classcello_1_1_update_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a368472e271247ac9336c4f8015270627" id="r_a368472e271247ac9336c4f8015270627"><td class="memItemLeft" align="right" valign="top"><a id="a368472e271247ac9336c4f8015270627" name="a368472e271247ac9336c4f8015270627"></a>
juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="memdesc:a368472e271247ac9336c4f8015270627"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tree where our data lives. <br /></td></tr>
<tr class="separator:a368472e271247ac9336c4f8015270627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ad57b7ba52f9a06b121b367d825b0" id="r_a8f7ad57b7ba52f9a06b121b367d825b0"><td class="memItemLeft" align="right" valign="top"><a id="a8f7ad57b7ba52f9a06b121b367d825b0" name="a8f7ad57b7ba52f9a06b121b367d825b0"></a>
juce::UndoManager *&#160;</td><td class="memItemRight" valign="bottom"><b>undoManager</b> { nullptr }</td></tr>
<tr class="memdesc:a8f7ad57b7ba52f9a06b121b367d825b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The undo manager to use for set() operations. <br /></td></tr>
<tr class="separator:a8f7ad57b7ba52f9a06b121b367d825b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef37de54c32241809154d63985719b3" id="r_a9ef37de54c32241809154d63985719b3"><td class="memItemLeft" align="right" valign="top"><a id="a9ef37de54c32241809154d63985719b3" name="a9ef37de54c32241809154d63985719b3"></a>
CreationType&#160;</td><td class="memItemRight" valign="bottom"><b>creationType</b> { CreationType::wrapped }</td></tr>
<tr class="memdesc:a9ef37de54c32241809154d63985719b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember how this <a class="el" href="classcello_1_1_object.html">Object</a> was created. <br /></td></tr>
<tr class="separator:a9ef37de54c32241809154d63985719b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c69af2cea29bfd1b1459bf262d58611" id="r_a7c69af2cea29bfd1b1459bf262d58611"><td class="memItemLeft" align="right" valign="top"><a id="a7c69af2cea29bfd1b1459bf262d58611" name="a7c69af2cea29bfd1b1459bf262d58611"></a>
juce::ValueTree::Listener *&#160;</td><td class="memItemRight" valign="bottom"><b>excludedListener</b> { nullptr }</td></tr>
<tr class="memdesc:a7c69af2cea29bfd1b1459bf262d58611"><td class="mdescLeft">&#160;</td><td class="mdescRight">a listener to <em>not</em> update when properties change. <br /></td></tr>
<tr class="separator:a7c69af2cea29bfd1b1459bf262d58611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1018e5ee26cdd37c7208b37fb26485" id="r_acd1018e5ee26cdd37c7208b37fb26485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd1018e5ee26cdd37c7208b37fb26485">doForceUpdates</a> { false }</td></tr>
<tr class="separator:acd1018e5ee26cdd37c7208b37fb26485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Child Operations</h2></td></tr>
<tr class="memitem:a0f473a558c1123b7fa3051aaf11432f5" id="r_a0f473a558c1123b7fa3051aaf11432f5"><td class="memItemLeft" align="right" valign="top"><a id="a0f473a558c1123b7fa3051aaf11432f5" name="a0f473a558c1123b7fa3051aaf11432f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b> = juce::ValueTree::Iterator</td></tr>
<tr class="separator:a0f473a558c1123b7fa3051aaf11432f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38132029a5eb1a89f9389e3804b9473d" id="r_a38132029a5eb1a89f9389e3804b9473d"><td class="memItemLeft" align="right" valign="top"><a id="a38132029a5eb1a89f9389e3804b9473d" name="a38132029a5eb1a89f9389e3804b9473d"></a>
Iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a38132029a5eb1a89f9389e3804b9473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d20a4b7f690426196d9c269eed8aa" id="r_a689d20a4b7f690426196d9c269eed8aa"><td class="memItemLeft" align="right" valign="top"><a id="a689d20a4b7f690426196d9c269eed8aa" name="a689d20a4b7f690426196d9c269eed8aa"></a>
Iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a689d20a4b7f690426196d9c269eed8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf02406e7aa4127d4c4f9117123fa9" id="r_ad8cf02406e7aa4127d4c4f9117123fa9"><td class="memItemLeft" align="right" valign="top">juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8cf02406e7aa4127d4c4f9117123fa9">operator[]</a> (int index) const</td></tr>
<tr class="memdesc:ad8cf02406e7aa4127d4c4f9117123fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a child tree of this object by its index. NOTE that it does not return an object; to work with this data in its <a class="el" href="classcello_1_1_object.html">cello::Object</a> form, you'll need to use this tree to create a new one, probably testing its type to make sure you're creating the correct <a class="el" href="classcello_1_1_object.html">Object</a> type from it.  <br /></td></tr>
<tr class="separator:ad8cf02406e7aa4127d4c4f9117123fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a5f2f969546e15cf78507a09b5b0dd" id="r_a86a5f2f969546e15cf78507a09b5b0dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86a5f2f969546e15cf78507a09b5b0dd">getNumChildren</a> () const</td></tr>
<tr class="memdesc:a86a5f2f969546e15cf78507a09b5b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check how many children this object has.  <br /></td></tr>
<tr class="separator:a86a5f2f969546e15cf78507a09b5b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfacbf6d9bcd8f237fda4cc91d1816b" id="r_accfacbf6d9bcd8f237fda4cc91d1816b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accfacbf6d9bcd8f237fda4cc91d1816b">append</a> (<a class="el" href="classcello_1_1_object.html">Object</a> *object)</td></tr>
<tr class="memdesc:accfacbf6d9bcd8f237fda4cc91d1816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new child object to the end of our child object list,.  <br /></td></tr>
<tr class="separator:accfacbf6d9bcd8f237fda4cc91d1816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a38a610eadc3fcf2bb9a358c7befa" id="r_ae45a38a610eadc3fcf2bb9a358c7befa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae45a38a610eadc3fcf2bb9a358c7befa">insert</a> (<a class="el" href="classcello_1_1_object.html">Object</a> *object, int index)</td></tr>
<tr class="memdesc:ae45a38a610eadc3fcf2bb9a358c7befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new child object at a specific index in the list.  <br /></td></tr>
<tr class="separator:ae45a38a610eadc3fcf2bb9a358c7befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91a10de733ff8c8bc3fa3729fd036a0" id="r_ab91a10de733ff8c8bc3fa3729fd036a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcello_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab91a10de733ff8c8bc3fa3729fd036a0">remove</a> (<a class="el" href="classcello_1_1_object.html">Object</a> *object)</td></tr>
<tr class="memdesc:ab91a10de733ff8c8bc3fa3729fd036a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to remove a child object from this.  <br /></td></tr>
<tr class="separator:ab91a10de733ff8c8bc3fa3729fd036a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd6547ac3a03479b2d7c55d44fef840" id="r_adcd6547ac3a03479b2d7c55d44fef840"><td class="memItemLeft" align="right" valign="top">juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd6547ac3a03479b2d7c55d44fef840">remove</a> (int index)</td></tr>
<tr class="memdesc:adcd6547ac3a03479b2d7c55d44fef840"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a child by its index.  <br /></td></tr>
<tr class="separator:adcd6547ac3a03479b2d7c55d44fef840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e394127066a7e14788dcf97b663ff1" id="r_a05e394127066a7e14788dcf97b663ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05e394127066a7e14788dcf97b663ff1">move</a> (int fromIndex, int toIndex)</td></tr>
<tr class="memdesc:a05e394127066a7e14788dcf97b663ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the position of one of this object's children.  <br /></td></tr>
<tr class="separator:a05e394127066a7e14788dcf97b663ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f55b2f7ddbfa99ad014da938144f1b" id="r_a16f55b2f7ddbfa99ad014da938144f1b"><td class="memTemplParams" colspan="2">template&lt;typename Comparator&gt; </td></tr>
<tr class="memitem:a16f55b2f7ddbfa99ad014da938144f1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16f55b2f7ddbfa99ad014da938144f1b">sort</a> (Comparator &amp;comp, bool stableSort)</td></tr>
<tr class="memdesc:a16f55b2f7ddbfa99ad014da938144f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort this object's children using the provided comparison object.  <br /></td></tr>
<tr class="separator:a16f55b2f7ddbfa99ad014da938144f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Callbacks</h2></td></tr>
<tr class="memitem:af5b6242a9cd4b6c2a14c5be1229fd5b1" id="r_af5b6242a9cd4b6c2a14c5be1229fd5b1"><td class="memItemLeft" align="right" valign="top"><a id="af5b6242a9cd4b6c2a14c5be1229fd5b1" name="af5b6242a9cd4b6c2a14c5be1229fd5b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChildUpdateFn</b> = std::function&lt;void (juce::ValueTree&amp; child, int oldIndex, int newIndex)&gt;</td></tr>
<tr class="separator:af5b6242a9cd4b6c2a14c5be1229fd5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa5e523d8206f4ccaab5fa603203c18" id="r_a5fa5e523d8206f4ccaab5fa603203c18"><td class="memItemLeft" align="right" valign="top"><a id="a5fa5e523d8206f4ccaab5fa603203c18" name="a5fa5e523d8206f4ccaab5fa603203c18"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SelfUpdateFn</b> = std::function&lt;void (void)&gt;</td></tr>
<tr class="separator:a5fa5e523d8206f4ccaab5fa603203c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dbeb9765fd5a479c3a7f29ae04ce19" id="r_a37dbeb9765fd5a479c3a7f29ae04ce19"><td class="memItemLeft" align="right" valign="top"><a id="a37dbeb9765fd5a479c3a7f29ae04ce19" name="a37dbeb9765fd5a479c3a7f29ae04ce19"></a>
ChildUpdateFn&#160;</td><td class="memItemRight" valign="bottom"><b>onChildAdded</b></td></tr>
<tr class="separator:a37dbeb9765fd5a479c3a7f29ae04ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322a23d59dd32f9682242e44b195d4a" id="r_a3322a23d59dd32f9682242e44b195d4a"><td class="memItemLeft" align="right" valign="top"><a id="a3322a23d59dd32f9682242e44b195d4a" name="a3322a23d59dd32f9682242e44b195d4a"></a>
ChildUpdateFn&#160;</td><td class="memItemRight" valign="bottom"><b>onChildRemoved</b></td></tr>
<tr class="separator:a3322a23d59dd32f9682242e44b195d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa166ad1df3c07ced806116aeb18284" id="r_a3aa166ad1df3c07ced806116aeb18284"><td class="memItemLeft" align="right" valign="top"><a id="a3aa166ad1df3c07ced806116aeb18284" name="a3aa166ad1df3c07ced806116aeb18284"></a>
ChildUpdateFn&#160;</td><td class="memItemRight" valign="bottom"><b>onChildMoved</b></td></tr>
<tr class="separator:a3aa166ad1df3c07ced806116aeb18284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be537664f66ac62c89dde556112571c" id="r_a0be537664f66ac62c89dde556112571c"><td class="memItemLeft" align="right" valign="top"><a id="a0be537664f66ac62c89dde556112571c" name="a0be537664f66ac62c89dde556112571c"></a>
SelfUpdateFn&#160;</td><td class="memItemRight" valign="bottom"><b>onParentChanged</b></td></tr>
<tr class="separator:a0be537664f66ac62c89dde556112571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2598690dfd07d3a36e4ae1ba0f08ae58" id="r_a2598690dfd07d3a36e4ae1ba0f08ae58"><td class="memItemLeft" align="right" valign="top"><a id="a2598690dfd07d3a36e4ae1ba0f08ae58" name="a2598690dfd07d3a36e4ae1ba0f08ae58"></a>
SelfUpdateFn&#160;</td><td class="memItemRight" valign="bottom"><b>onTreeRedirected</b></td></tr>
<tr class="separator:a2598690dfd07d3a36e4ae1ba0f08ae58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d19efd1b7b1e1c9fa3dd2cd20a11c90" id="r_a3d19efd1b7b1e1c9fa3dd2cd20a11c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d19efd1b7b1e1c9fa3dd2cd20a11c90">onPropertyChange</a> (const juce::Identifier &amp;id, PropertyUpdateFn callback)</td></tr>
<tr class="memdesc:a3d19efd1b7b1e1c9fa3dd2cd20a11c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install (or clear) a function to be called when one of this <a class="el" href="classcello_1_1_object.html">Object</a>'s properties changes. A cello extension to this mechanism is that you can pass in the type id of this tree, and you'll receive a callback on that key when any of the other properties that don't have a handler have changed.  <br /></td></tr>
<tr class="separator:a3d19efd1b7b1e1c9fa3dd2cd20a11c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5307d2bbb3280be1b9d544bad4fcac64" id="r_a5307d2bbb3280be1b9d544bad4fcac64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5307d2bbb3280be1b9d544bad4fcac64">onPropertyChange</a> (PropertyUpdateFn callback)</td></tr>
<tr class="memdesc:a5307d2bbb3280be1b9d544bad4fcac64"><td class="mdescLeft">&#160;</td><td class="mdescRight">install or clear a generic callback that will be called when any property in the object changes. The identifier of the property that changed will be passed to the callback.  <br /></td></tr>
<tr class="separator:a5307d2bbb3280be1b9d544bad4fcac64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76c604f03632096881fbcbd33835b6f" id="r_ab76c604f03632096881fbcbd33835b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab76c604f03632096881fbcbd33835b6f">onPropertyChange</a> (const <a class="el" href="classcello_1_1_value_base.html">ValueBase</a> &amp;val, PropertyUpdateFn callback)</td></tr>
<tr class="memdesc:ab76c604f03632096881fbcbd33835b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a property change callback by passing in a reference to a <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">Value</a> object instead of its id.  <br /></td></tr>
<tr class="separator:ab76c604f03632096881fbcbd33835b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">File operations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>save/load objects to/from disk. </p>
</td></tr>
<tr class="memitem:a5162885cca204640f836e776fcdd1cb9" id="r_a5162885cca204640f836e776fcdd1cb9"><td class="memItemLeft" align="right" valign="top">juce::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5162885cca204640f836e776fcdd1cb9">save</a> (juce::File file, FileFormat format=FileFormat::xml) const</td></tr>
<tr class="memdesc:a5162885cca204640f836e776fcdd1cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the object tree to disk.  <br /></td></tr>
<tr class="separator:a5162885cca204640f836e776fcdd1cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05bcbdf54e3587a9060dba4caeba462" id="r_ad05bcbdf54e3587a9060dba4caeba462"><td class="memItemLeft" align="right" valign="top">static juce::ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05bcbdf54e3587a9060dba4caeba462">load</a> (juce::File file, FileFormat format=FileFormat::xml)</td></tr>
<tr class="memdesc:ad05bcbdf54e3587a9060dba4caeba462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload data from disk. Used in the ctor that accepts file name and format.  <br /></td></tr>
<tr class="separator:ad05bcbdf54e3587a9060dba4caeba462"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e0aab983b0079b72a5cc652ef06e775" name="a4e0aab983b0079b72a5cc652ef06e775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0aab983b0079b72a5cc652ef06e775">&#9670;&#160;</a></span>Object() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const juce::String &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcello_1_1_object.html">cello::Object</a> object, which will attempt to initialize from the 'state' parameter. If 'state' contains a ValueTree of the requested type, we'll use that as our store. </p>
<p>Otherwise, we look for a child of our type: if found, we use that as our data. if not found, we create and (default) intialize a new tree of our type and add it as a child to the tree pointed to by state. If state is nullptr, we create and default-initialize a new tree object.</p>
<p>We register as a listener to whatever value tree we just found or created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">state</td><td>pointer to a <a class="el" href="classcello_1_1_object.html">cello::Object</a>; pass nullptr to default initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63a891dc061e42fafeacbe0a2aa01607" name="a63a891dc061e42fafeacbe0a2aa01607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a891dc061e42fafeacbe0a2aa01607">&#9670;&#160;</a></span>Object() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const juce::String &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcello_1_1_object.html">Object</a>, initializing from the <code>state</code> argument. Follows the same descent logic used in the above constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d80db10512c4cfa708543ccf83e3428" name="a3d80db10512c4cfa708543ccf83e3428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d80db10512c4cfa708543ccf83e3428">&#9670;&#160;</a></span>Object() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const juce::String &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">juce::ValueTree</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> from a raw juce ValueTree. Its behavior mimics that of the ctor that accepts a pointer to object, attempting to either: </p>
<ul>
<li>use the tree directly (if its type matches ours)</li>
<li>look inside it for a tree of the correct type</li>
<li>if that's not found (or the initial tree wasn't valid) , create a tree/Object of the correct type and add it to the tree that was passed in.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">tree</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a186ba097370a8a778be2314c37d6c" name="a11a186ba097370a8a778be2314c37d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a186ba097370a8a778be2314c37d6c">&#9670;&#160;</a></span>Object() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const juce::String &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">juce::File</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Object::FileFormat</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FileFormat::xml</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> by attempting to load it from a file on disk. You can test whether this succeeded by checking the return value of <code><a class="el" href="#ae04aa9d628d2ee279d9d467c8caf73d8" title="Determine how this object was created, which will be one of:">getCreationType()</a></code> &ndash; if its value is <code>CreationType::initialized</code>, the load from disk failed, and this instance was default-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0d5d0df3615b3a6a294929d16fd90ce" name="ad0d5d0df3615b3a6a294929d16fd90ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d5d0df3615b3a6a294929d16fd90ce">&#9670;&#160;</a></span>Object() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcello_1_1_object.html">Object</a> object as a copy of an existing one. We register as a listener, but this new copy does not have any callbacks registered. Both objects will point at the same shared value tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="classcello_1_1_object.html">Object</a> to initialize ourselves from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accfacbf6d9bcd8f237fda4cc91d1816b" name="accfacbf6d9bcd8f237fda4cc91d1816b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfacbf6d9bcd8f237fda4cc91d1816b">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new child object to the end of our child object list,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a887fbb6f22d47fc6e2cdfec57c320efe" name="a887fbb6f22d47fc6e2cdfec57c320efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887fbb6f22d47fc6e2cdfec57c320efe">&#9670;&#160;</a></span>canRedo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::canRedo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether this object/tree has anything that can be redone. </p>
<dl class="section return"><dt>Returns</dt><dd>false if there's no undo manager or nothing to redo </dd></dl>

</div>
</div>
<a id="a6cace96ea91fd79dfc17cb44b9c4fbf9" name="a6cace96ea91fd79dfc17cb44b9c4fbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cace96ea91fd79dfc17cb44b9c4fbf9">&#9670;&#160;</a></span>canUndo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::canUndo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether this object/tree has anything that can be undone. </p>
<dl class="section return"><dt>Returns</dt><dd>false if there's no undo manager or nothing to undo </dd></dl>

</div>
</div>
<a id="a62394b84057f6fce787bc8cf61c4facb" name="a62394b84057f6fce787bc8cf61c4facb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62394b84057f6fce787bc8cf61c4facb">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::clone </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make and return a copy of our underlying value tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deep</td><td>Include children? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this thing. </dd></dl>

</div>
</div>
<a id="a7fd4f6b747c7c120ded85f09765378af" name="a7fd4f6b747c7c120ded85f09765378af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd4f6b747c7c120ded85f09765378af">&#9670;&#160;</a></span>delattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::delattr </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified property from this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b25ab25ee62b03dda46143a20054c02" name="a4b25ab25ee62b03dda46143a20054c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b25ab25ee62b03dda46143a20054c02">&#9670;&#160;</a></span>excludeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::excludeListener </td>
          <td>(</td>
          <td class="paramtype">juce::ValueTree::Listener *</td>          <td class="paramname"><span class="paramname"><em>listener</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A listener to exclude from property change updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa28a19ff0e4f6e6c826e7293e1937d23" name="aa28a19ff0e4f6e6c826e7293e1937d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28a19ff0e4f6e6c826e7293e1937d23">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a query against the children of this <a class="el" href="classcello_1_1_object.html">Object</a>, returning a new ValueTree containing zero or more copies of child trees that match the query, possibly sorted into a different order than they exist in this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td><a class="el" href="classcello_1_1_query.html">Query</a> object that defines the search/sort criteria </td></tr>
    <tr><td class="paramname">deep</td><td>if true, also copy sub-items from object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>juce::ValueTree </dd></dl>

</div>
</div>
<a id="aa7230b2a5bdaedf19fd3b6487e40138f" name="aa7230b2a5bdaedf19fd3b6487e40138f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7230b2a5bdaedf19fd3b6487e40138f">&#9670;&#160;</a></span>findOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::findOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a query against the children of this object, returning a copy of the first child found that meets the predicates in the query object, or an empty tree if none is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td><a class="el" href="classcello_1_1_query.html">Query</a> object that defines the search/sort criteria </td></tr>
    <tr><td class="paramname">deep</td><td>if true, also copy sub-items from object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>juce::ValueTree copy of a matching child tree or {} </dd></dl>

</div>
</div>
<a id="a6a23c8172d0df906594e9d222dd6e441" name="a6a23c8172d0df906594e9d222dd6e441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a23c8172d0df906594e9d222dd6e441">&#9670;&#160;</a></span>getattr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cello::Object::getattr </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>defaultVal</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property value from this object, or default if it doesn't have a property with that name. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td></td></tr>
    <tr><td class="paramname">defaultVal</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="ae04aa9d628d2ee279d9d467c8caf73d8" name="ae04aa9d628d2ee279d9d467c8caf73d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04aa9d628d2ee279d9d467c8caf73d8">&#9670;&#160;</a></span>getCreationType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CreationType cello::Object::getCreationType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine how this object was created, which will be one of: </p>
<ul>
<li>CreationType::initialized &ndash; All values were default-initialized</li>
<li>CreationType::wrapped &ndash; this object refers to a value tree that already existed</li>
</ul>
<p>It might be an error in your application to expect one or the other and not find it at runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>CreationType </dd></dl>

</div>
</div>
<a id="a36491bac36514cc7e88454d8444d0a0f" name="a36491bac36514cc7e88454d8444d0a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36491bac36514cc7e88454d8444d0a0f">&#9670;&#160;</a></span>getExcludedListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree::Listener * cello::Object::getExcludedListener </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the listener to exclude from property change updates. </p>
<dl class="section return"><dt>Returns</dt><dd>juce::ValueTree::Listener* </dd></dl>

</div>
</div>
<a id="a86a5f2f969546e15cf78507a09b5b0dd" name="a86a5f2f969546e15cf78507a09b5b0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a5f2f969546e15cf78507a09b5b0dd">&#9670;&#160;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cello::Object::getNumChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check how many children this object has. </p>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a9365e8cc11d3d6ea98957cf150450b1a" name="a9365e8cc11d3d6ea98957cf150450b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9365e8cc11d3d6ea98957cf150450b1a">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">juce::Identifier cello::Object::getType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of this object as a juce::Identifier. </p>
<dl class="section return"><dt>Returns</dt><dd>juce::Identifier </dd></dl>

</div>
</div>
<a id="a007c7f790afc2b708da43601d00f38cf" name="a007c7f790afc2b708da43601d00f38cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007c7f790afc2b708da43601d00f38cf">&#9670;&#160;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">juce::String cello::Object::getTypeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of this object as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>juce::String </dd></dl>

</div>
</div>
<a id="aa19bde9dc0f5ae807641414d8e890d44" name="aa19bde9dc0f5ae807641414d8e890d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19bde9dc0f5ae807641414d8e890d44">&#9670;&#160;</a></span>getUndoManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::UndoManager * cello::Object::getUndoManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current undo manager; only useful to this object's <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">Value</a> objects and when creating other Objects to wrap our subtrees. </p>
<dl class="section return"><dt>Returns</dt><dd>juce::UndoManager* </dd></dl>

</div>
</div>
<a id="a556d736691db1d05b208a8b3c6f58ebd" name="a556d736691db1d05b208a8b3c6f58ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556d736691db1d05b208a8b3c6f58ebd">&#9670;&#160;</a></span>hasattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::hasattr </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test the object to see if it has an attribute with this id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ae45a38a610eadc3fcf2bb9a358c7befa" name="ae45a38a610eadc3fcf2bb9a358c7befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45a38a610eadc3fcf2bb9a358c7befa">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new child object at a specific index in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td></td></tr>
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad05bcbdf54e3587a9060dba4caeba462" name="ad05bcbdf54e3587a9060dba4caeba462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05bcbdf54e3587a9060dba4caeba462">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::load </td>
          <td>(</td>
          <td class="paramtype">juce::File</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FileFormat</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FileFormat::xml</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reload data from disk. Used in the ctor that accepts file name and format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">format</td><td>one of (xml, binary, zipped) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ValueTree, invalid if the attempt to load failed. </dd></dl>

</div>
</div>
<a id="a05e394127066a7e14788dcf97b663ff1" name="a05e394127066a7e14788dcf97b663ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e394127066a7e14788dcf97b663ff1">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::move </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fromIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>toIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the position of one of this object's children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td></td></tr>
    <tr><td class="paramname">toIndex</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d19efd1b7b1e1c9fa3dd2cd20a11c90" name="a3d19efd1b7b1e1c9fa3dd2cd20a11c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d19efd1b7b1e1c9fa3dd2cd20a11c90">&#9670;&#160;</a></span>onPropertyChange() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyUpdateFn</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install (or clear) a function to be called when one of this <a class="el" href="classcello_1_1_object.html">Object</a>'s properties changes. A cello extension to this mechanism is that you can pass in the type id of this tree, and you'll receive a callback on that key when any of the other properties that don't have a handler have changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the property that has changed. </td></tr>
    <tr><td class="paramname">callback</td><td>function to call on update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab76c604f03632096881fbcbd33835b6f" name="ab76c604f03632096881fbcbd33835b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76c604f03632096881fbcbd33835b6f">&#9670;&#160;</a></span>onPropertyChange() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_value_base.html">ValueBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyUpdateFn</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register a property change callback by passing in a reference to a <a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">Value</a> object instead of its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5307d2bbb3280be1b9d544bad4fcac64" name="a5307d2bbb3280be1b9d544bad4fcac64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5307d2bbb3280be1b9d544bad4fcac64">&#9670;&#160;</a></span>onPropertyChange() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">PropertyUpdateFn</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>install or clear a generic callback that will be called when any property in the object changes. The identifier of the property that changed will be passed to the callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab9527be361c6013e97bda636a549d6e" name="aab9527be361c6013e97bda636a549d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9527be361c6013e97bda636a549d6e">&#9670;&#160;</a></span>operator juce::ValueTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cello::Object::operator juce::ValueTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ValueTree we're using as our data store. </p>
<dl class="section return"><dt>Returns</dt><dd>juce::ValueTree </dd></dl>

</div>
</div>
<a id="ad43381ba2a3be680f308b6d1bfc284e3" name="ad43381ba2a3be680f308b6d1bfc284e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43381ba2a3be680f308b6d1bfc284e3">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcello_1_1_object.html">Object</a> &amp; cello::Object::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set this object to use a different <a class="el" href="classcello_1_1_object.html">Object</a>'s value tree, which we will begin listening to. Our <code>valueTreeRedirected</code> callback should be executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcello_1_1_object.html">Object</a>&amp; </dd></dl>

</div>
</div>
<a id="a3fabc22c50460fc720c8be1c3384db70" name="a3fabc22c50460fc720c8be1c3384db70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fabc22c50460fc720c8be1c3384db70">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::operator== </td>
          <td>(</td>
          <td class="paramtype">const juce::ValueTree &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test for true equivalence: does this object point to the same underlying tree as the tree on the right hand side? Note that because <a class="el" href="classcello_1_1_object.html">cello::Object</a> has <code>operator juce::ValueTree</code>, you can pass a reference to <a class="el" href="classcello_1_1_object.html">Object</a> as the rhs and it will work correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the same tree is on both sides. </dd></dl>

</div>
</div>
<a id="ad8cf02406e7aa4127d4c4f9117123fa9" name="ad8cf02406e7aa4127d4c4f9117123fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cf02406e7aa4127d4c4f9117123fa9">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a child tree of this object by its index. NOTE that it does not return an object; to work with this data in its <a class="el" href="classcello_1_1_object.html">cello::Object</a> form, you'll need to use this tree to create a new one, probably testing its type to make sure you're creating the correct <a class="el" href="classcello_1_1_object.html">Object</a> type from it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>juce::ValueTree; will be invalid if the index is out of range. </dd></dl>

</div>
</div>
<a id="a534edaa253affc488dba210e86e55ccf" name="a534edaa253affc488dba210e86e55ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534edaa253affc488dba210e86e55ccf">&#9670;&#160;</a></span>redo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::redo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to redo the last transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>false if there's no undo manager, nothing to redo, or the attempt to redo fails. </dd></dl>

</div>
</div>
<a id="a43cc2848d284422f9fa6ae24fc7f7ed6" name="a43cc2848d284422f9fa6ae24fc7f7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cc2848d284422f9fa6ae24fc7f7ed6">&#9670;&#160;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cello::Object::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_query.html">cello::Query</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all children from the tree that match the query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int number of children removed. </dd></dl>

</div>
</div>
<a id="adcd6547ac3a03479b2d7c55d44fef840" name="adcd6547ac3a03479b2d7c55d44fef840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd6547ac3a03479b2d7c55d44fef840">&#9670;&#160;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::ValueTree cello::Object::remove </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove a child by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Invalid tree if the index was out of bounds. </dd></dl>

</div>
</div>
<a id="ab91a10de733ff8c8bc3fa3729fd036a0" name="ab91a10de733ff8c8bc3fa3729fd036a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91a10de733ff8c8bc3fa3729fd036a0">&#9670;&#160;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcello_1_1_object.html">Object</a> * cello::Object::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to remove a child object from this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td><a class="el" href="classcello_1_1_object.html">Object</a> containing sub-tree to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr on failure (the specified object wasn't a child) </dd></dl>

</div>
</div>
<a id="a5162885cca204640f836e776fcdd1cb9" name="a5162885cca204640f836e776fcdd1cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5162885cca204640f836e776fcdd1cb9">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">juce::Result cello::Object::save </td>
          <td>(</td>
          <td class="paramtype">juce::File</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FileFormat</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FileFormat::xml</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the object tree to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">format</td><td>one of (xml, binary, zipped) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the save operation. </dd></dl>

</div>
</div>
<a id="a39df4cb5bd79fd770ad23184d5ef8c87" name="a39df4cb5bd79fd770ad23184d5ef8c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39df4cb5bd79fd770ad23184d5ef8c87">&#9670;&#160;</a></span>setattr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcello_1_1_object.html">Object</a> &amp; cello::Object::setattr </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>attrVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new value for the specified attribute/property. We return a reference to this object so that setattr calls may be chained. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td></td></tr>
    <tr><td class="paramname">attrVal</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e852dd0a299e2d72bf07dd8970b52a" name="a14e852dd0a299e2d72bf07dd8970b52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e852dd0a299e2d72bf07dd8970b52a">&#9670;&#160;</a></span>setUndoManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::setUndoManager </td>
          <td>(</td>
          <td class="paramtype">juce::UndoManager *</td>          <td class="paramname"><span class="paramname"><em>undo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the undo manager to use in this object (and others created from it). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">undo</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16f55b2f7ddbfa99ad014da938144f1b" name="a16f55b2f7ddbfa99ad014da938144f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f55b2f7ddbfa99ad014da938144f1b">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::sort </td>
          <td>(</td>
          <td class="paramtype">Comparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>stableSort</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort this object's children using the provided comparison object. </p>
<p>The <code>comp</code> object must contain a method that uses the signature: <code>int compareElements (const ValueTree&amp; first, const ValueTree&amp; second)</code> and returns</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td></td></tr>
    <tr><td class="paramname">stableSort</td><td>true to keep equivalent items in the same order after sorting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb33870b81e819ffa3e6d598a7eefffb" name="aeb33870b81e819ffa3e6d598a7eefffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb33870b81e819ffa3e6d598a7eefffb">&#9670;&#160;</a></span>toXmlString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">juce::String cello::Object::toXmlString </td>
          <td>(</td>
          <td class="paramtype">const juce::XmlElement::TextFormat &amp;</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a string representation of this object's tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>specifies details of the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>juce::String </dd></dl>

</div>
</div>
<a id="a9068e0306934dcbf2c24b71efe5c1024" name="a9068e0306934dcbf2c24b71efe5c1024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9068e0306934dcbf2c24b71efe5c1024">&#9670;&#160;</a></span>undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::undo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to undo the last transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>false if there's no undo manager, nothing to undo, or the attempt to undo fails. </dd></dl>

</div>
</div>
<a id="abef5e5b7d054ac2ab811cde202b27889" name="abef5e5b7d054ac2ab811cde202b27889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef5e5b7d054ac2ab811cde202b27889">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::update </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;</td>          <td class="paramname"><span class="paramname"><em>updateBlock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply delta/update generated by the juce::ValueTreeSynchroniser class; this is used in the sync and ipc implementations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateBlock</td><td>Binary data to apply to this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26a8d3a310c6ac67498f762224f09daf" name="a26a8d3a310c6ac67498f762224f09daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a8d3a310c6ac67498f762224f09daf">&#9670;&#160;</a></span>upsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::upsert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update or insert a child object (concept borrowed from MongoDB) Looks for a child with a 'key' value that matches the one found in the object we've been passed. If a match is found, we update the entry in place (update). If no match is found, we append a copy of <code>object</code> to our children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td><a class="el" href="classcello_1_1_object.html">Object</a> with data to update or add </td></tr>
    <tr><td class="paramname">key</td><td>property name to use to match the two entries </td></tr>
    <tr><td class="paramname">deep</td><td>if true, also copy sub-items from object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the object being added doesn't have the key property. </dd></dl>

</div>
</div>
<a id="ae4f3e07c7db1d4d8af104d9ea5c63883" name="ae4f3e07c7db1d4d8af104d9ea5c63883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f3e07c7db1d4d8af104d9ea5c63883">&#9670;&#160;</a></span>upsertAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cello::Object::upsertAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const juce::Identifier &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an upsert using each of the children of the parent being passed. Common workflow here: </p>
<ol type="1">
<li>perform a query to get a list of copies of some children.</li>
<li>modify those copies</li>
<li>Update them in place in their original parent container.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>object with children to use as update sources </td></tr>
    <tr><td class="paramname">key</td><td>key to match children together </td></tr>
    <tr><td class="paramname">deep</td><td>copy subtrees as well? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42e737e33370e4f888052cca6a2c90cc" name="a42e737e33370e4f888052cca6a2c90cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e737e33370e4f888052cca6a2c90cc">&#9670;&#160;</a></span>wasInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::wasInitialized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility method to test the creation type as a bool. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this object was created by default initialization. </dd></dl>

</div>
</div>
<a id="a55254d40c64fc95eb3b4a774b8d406b2" name="a55254d40c64fc95eb3b4a774b8d406b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55254d40c64fc95eb3b4a774b8d406b2">&#9670;&#160;</a></span>wasWrapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::wasWrapped </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility method to test the creation type as a bool. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this object was created by wrapping an existing tree. </dd></dl>

</div>
</div>
<a id="a41128bc9a0e36952a2ea053d332455e2" name="a41128bc9a0e36952a2ea053d332455e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41128bc9a0e36952a2ea053d332455e2">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Object::CreationType cello::Object::wrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcello_1_1_object.html">Object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap another <a class="el" href="classcello_1_1_object.html">Object</a>'s tree after this object is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CreationType, whether we were able to wrap that object or created a newly initialized child of it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acd1018e5ee26cdd37c7208b37fb26485" name="acd1018e5ee26cdd37c7208b37fb26485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1018e5ee26cdd37c7208b37fb26485">&#9670;&#160;</a></span>doForceUpdates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cello::Object::doForceUpdates { false }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>should we send property change notifications even if a property doesn't change? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cello/<a class="el" href="cello__object_8h_source.html">cello_object.h</a></li>
<li>cello/<a class="el" href="cello__object_8cpp_source.html">cello_object.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cello</b></li><li class="navelem"><a class="el" href="classcello_1_1_object.html">Object</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
