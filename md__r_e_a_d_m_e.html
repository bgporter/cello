<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cello: Cello</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="cello_cello.png"/></td>
  <td id="projectalign">
   <div id="projectname">cello
   </div>
   <div id="projectbrief">Classes for working with JUCE ValueTrees</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Cello </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Classes for working with juce ValueTree objects.</p>
<p><b>Fall 2022 * Brett g Porter</b></p>
<p><a href="#" onclick="location.href='mai'+'lto:'+'bre'+'tt'+'@bg'+'po'+'rte'+'r.'+'net'; return false;">brett<span class="obfuscator">.nosp@m.</span>@bgp<span class="obfuscator">.nosp@m.</span>orter<span class="obfuscator">.nosp@m.</span>.net</a></p>
<p>API docs available <a href="https://bgporter.github.io/cello/">here</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Motivation and Overview</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Confessions of a &lt;tt&gt;ValueTree&lt;/tt&gt; Skeptic</h2>
<p>I've been using the JUCE framework for over a decade now, but there's a major component of JUCE that never clicked for me as a developer &mdash; ValueTrees. This wasn't a problem for me until I changed jobs and started needing to work on a mature codebase that made significant use of them. This code makes efforts to hide some of the more cumbersome or repetitive aspects of integrating ValueTrees into an application, but that <code>ValueTreeWrapper</code> class still seemed like it required too much effort to work with; where I'm used to thinking in terms of objects that contain values, any time I needed to get near data that's stored in a ValueTree, it was impossible to avoid the awareness that I was always working through an API to perform operations on data that should just be directly manipulable, and while the wrapper class approach mitigated this to some extent, there was still more boilerplate code to write than seems good to me, as well as other places where the gaps around the abstraction were more obvious than I like.;</p>
<p>I've always found that the only way for me to work through these issues when I encounter them is to sit down with a blank document in an editor and start enumerating the problems that I see with a system and use that as a guide to start thinking about ways that I can engineer around the parts that aren' tmy favorite, and sometimes how I can reframe my thinking to start seeing superpowers where I thought there were deficiencies.</p>
<p>One of my current teammates has expressed confusion that I wasn't immediately on board with ValueTrees, and his defense of them was key to my eventually starting this re-analysis. They give you:</p>
<ul>
<li>A really easy way to capture and pass around the entire state of your application's data at run time</li>
<li>A rich mechanism to watch that data at a fine degree of granularity</li>
<li>Trivially easy persistence of application state</li>
</ul>
<p>...but at the cost (in comparison to using native POD or class/struct variables) of being:</p><ul>
<li>slower</li>
<li>less convenient to use</li>
<li>less type-safe, since all values are stored in the JUCE <code>var</code> variant type.</li>
</ul>
<p>As I started listing the tradeoffs, I considered ways to work around the convenience and type-safety issues. I also reflected on the years in my career when I wrote far more Python code than I did C++, and many of these same charges can be filed against that language, which I love.</p>
<p>At one level, you can look at Python as being nothing but a bunch of associative arrays (or in python, <code>dict</code>s) with the ability to be manipulated dynamically by code. Once I started thinking in those terms, the project became much more interesting.</p>
<p>As frequently happens with me, these thoughts sat collecting dust in a document until I hit upon a name for the project &mdash; <code>cello</code>, short for 'cellophane' (since the code is wrapping a ValueTree)</p>
<h2><a class="anchor" id="autotoc_md3"></a>
&lt;tt&gt;cello&lt;/tt&gt;</h2>
<p>In short, my goal was: create a set of C++ classes that I can derive my own classes from where member variables are stored transparently in JUCE ValueTrees instead of directly in those object instances, combining the comfort and simplicity of working with normal-looking C++ code with the benefits and tradeoffs of ValueTrees.</p>
<p>Something similar to:</p>
<div class="fragment"><div class="line"><span class="comment">// define a struct with two members and then create an instance</span></div>
<div class="line"><span class="keyword">struct </span>CelloDemo : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// we&#39;ll figure this type out shortly...</span></div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x;</div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;float&gt;</a> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">CelloDemo demoObject;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// give that object a lambda to call whenever the value of `x` changes. </span></div>
<div class="line">demoObject.onPropertyChange(demoObject.x, [&amp;demoObject] () </div>
<div class="line">{ </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;x changed to &quot;</span> &lt;&lt; demoObject.x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after executing this line, stdout should print: &quot;x changed to 100&quot;</span></div>
<div class="line">demoObject.x = 100;</div>
<div class="ttc" id="aclasscello_1_1_object_html"><div class="ttname"><a href="classcello_1_1_object.html">cello::Object</a></div><div class="ttdef"><b>Definition:</b> cello_object.h:32</div></div>
<div class="ttc" id="aclasscello_1_1_value_html"><div class="ttname"><a href="classcello_1_1_value.html">cello::Value</a></div><div class="ttdoc">A class to abstract away the issues around storing and retrieving a value from a ValueTree....</div><div class="ttdef"><b>Definition:</b> cello_value.h:68</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md4"></a>
Values</h1>
<ul>
<li>actually, a proxy to a value. We store a <code>juce::Identifier</code> and a reference to a ValueTree that provides the actual storage; storing or retrieving the value through its variable needs to do so through the ValueTree API, but that's all kept out of sight.</li>
<li>can be set to always update their listeners when the value is set, even if the underlying value wasn't changed.</li>
<li>can be given validator functions that will be called when the value is set or retrieved.</li>
<li>arithmetic types have all of the in-place operators (<code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>) defined.</li>
<li>can be used to access any C++ value data type for which a <code>juce::VariantConverter</code> struct has been defined.</li>
</ul>
<p><code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> objects only make sense as members of a class derived from <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> (below). The signature of the Value constuctor is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Value::Value (Object&amp; <span class="keywordtype">object</span>, <span class="keyword">const</span> juce::Identifier&amp; <span class="keywordtype">id</span>, T initVal);</div>
</div><!-- fragment --><p>...so at creation time, a value knows:</p><ol type="1">
<li>the Object holding a ValueTree where its storage is located</li>
<li>the identifier of this piece of data in the value tree</li>
<li>how to initialize that data if needed</li>
<li>The data type to use outside of the ValueTree. Because we use the <code>VariantConverter</code> facility in JUCE, almost any type of data can be converted to/from the <code>var</code> variant type.</li>
</ol>
<p>So, declaring an instance of this type templated on <code>int</code> as a member of a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> object would look like</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x { *<span class="keyword">this</span>, <span class="stringliteral">&quot;x&quot;</span>, {} };</div>
</div><!-- fragment --><p>We pass a reference to the owning object, the ID to use, and its default initial value. By convention, we use the same name for the member variable as for its Identifier in the ValueTree.</p>
<p>We define a macro in <code><a class="el" href="cello__value_8h_source.html">cello_value.h</a></code> that's less cumbersome and less potentially error-prone to do the same thing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAKE_VALUE_MEMBER(type, name, init) \</span></div>
<div class="line"><span class="preprocessor">    cello::Value&lt;type&gt; name { *this, #name, init };</span></div>
</div><!-- fragment --><p>...so the above declaration would be <code>MAKE_VALUE_MEMBER (int, x, {});</code>. Once a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> containing this declaration is instantiated, you can manipulate that value almost exactly the same as if it were an actual instance of the underlying type ("almost exactly" here covers edge cases like <code>sizeof</code> giving different results, and probably others that I haven't considered yet):</p>
<div class="fragment"><div class="line"><span class="comment">// after each of these lines, any property change callbacks watching </span></div>
<div class="line"><span class="comment">// `x` will be called. </span></div>
<div class="line">myObj.x = 20;</div>
<div class="line">--myObj.x;</div>
<div class="line">myObj.x *= -3;</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md5"></a>
&lt;tt&gt;VariantConverter&lt;/tt&gt;s</h2>
<p>By defining a template specialization of the <code>juce::VariantConverter</code> struct, you can store more complex value types by cleverly packing them inside one of the more interesting <code>var</code> variants that exist &mdash; in this example from the <code>cello</code> unit tests, we use the fact that an <code>Array</code> of <code>var</code>s is a <code>var</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>juce</div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>VariantConverter&lt;std::complex&lt;float&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> std::complex&lt;float&gt; fromVar (<span class="keyword">const</span> var&amp; v)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* array = v.getArray (); array != <span class="keyword">nullptr</span> &amp;&amp; array-&gt;size () == 2)</div>
<div class="line">            <span class="keywordflow">return</span> { array-&gt;getUnchecked (0), array-&gt;getUnchecked (1) };</div>
<div class="line">        jassertfalse;</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> var toVar (<span class="keyword">const</span> std::complex&lt;float&gt;&amp; val)</div>
<div class="line">    {</div>
<div class="line">        Array&lt;var&gt; array;</div>
<div class="line">        array.set (0, val.real ());</div>
<div class="line">        array.set (1, val.imag ());</div>
<div class="line">        <span class="keywordflow">return</span> { std::move (array) };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace juce</span></div>
</div><!-- fragment --><p>Then we define a class that has a single public Value member that contains a <code>std::complex&lt;float&gt;</code> &mdash; there's no additional work required to perform the conversions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ObjectWithConvertibleObject : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ObjectWithConvertibleObject ()</div>
<div class="line">    : cello::Object (<span class="stringliteral">&quot;convertible&quot;</span>, nullptr)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// verify the automatic use of variant converters.</span></div>
<div class="line">    MAKE_VALUE_MEMBER (std::complex&lt;float&gt;, complexVal, {});</div>
<div class="line">};</div>
</div><!-- fragment --><p>Your code is then free to work with that value directly:</p>
<div class="fragment"><div class="line">ObjectWithConvertibleObject o;</div>
<div class="line">std::complex&lt;float&gt; orig { 2.f, 3.f };</div>
<div class="line">o.complexVal = orig;</div>
<div class="line"> </div>
<div class="line">std::complex&lt;float&gt; retrieved { o.complexVal };</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.real (), retrieved.real (), 0.001f);</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.imag (), retrieved.imag (), 0.001f);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md6"></a>
Validator Functions</h2>
<p>If we're taking some inspiration from Python here, it's worth remembering that Python developers are in the practice of leaving all their class member variables public instead of hiding them behind a wall or privacy and forcing the usage of <code>getVariable()</code>/<code>setVariable()</code> methods to ensure the separation of interface from implementation &mdash; much of the time, there's no reason to require those accessor/mutator methods, and when there is an actual reason (for example, to ensure the maintenance of a class invariant), it's easy to switch over to using a property to manage access to the underlying data. Bertrand Meyer, creator of the Eiffel programming language refers to this as the "Uniform Access Principle," that "...all services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation."</p>
<p>Each <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> object may have <code>ValidatePropertyFn</code> lambdas assigned to it (where that lambda accepts a const reference to <code>T</code> and returns a <code>T</code> by value) that are (<code>onSet</code>) called before that value is stored into the underlying ValueTree or (<code>onGet</code>) called after retrieving the property from the ValueTree but before returning the value to calling code.</p>
<p>Your application can use this facility to modify the value (e.g. to keep it within a valid range), create an entirely new value, make changes to other properties of the ValueTree, create log entries, or anything else that you need to happen at these juncture points.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Forcing Update Callbacks</h2>
<p>The normal behavior of ValueTrees is to only notify callback listeners of property changes when a value actually <em>changes</em>. In practice, it's frequently useful to ensure that any attempt to set a property results in notifications being sent even if setting it to its current value. This can be controlled on a per-value basis by calling that value's <code>forceUpdate (bool shouldForceUpdate)</code> method.</p>
<p>To simplify the common case where this behavior is only meant to be in force for a single update, we provide a utility class <code>ScopedForceUpdater</code> that sets the value to force sending updates when the class is constructed, and then clears the update logic when that updater object goes out of scope.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Excluding Listeners</h2>
<p>It's also common to want to send update callbacks to all listeners except one &mdash; for example, if I have a bit of code that's setting a value and that code is also listening to the value, there's no need to receive a callback; the code already knows what the new value is. The <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> class provides a method <code>void excludeListener (juce::ValueTree::Listener* listener)</code> for this purpose.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Objects</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Creation Patterns: Creating vs Wrapping</h2>
<p>Since our objects rely on separate ValueTree objects for their storage, we need to support two different mechanisms for creating instances:</p>
<ol type="1">
<li>If the ValueTree doesn't exist yet, we need to create one and initialize it for use.</li>
<li>When the value tree already exists, we need to 'wrap' it to access its storage and capabilities.</li>
</ol>
<p>The constructors of <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> handle both these cases for us, using the logic outlined below:</p>
<ul>
<li><code>Object (juce::Identifier type, Object* state);</code> (preferred)</li>
<li><code>Object (juce::Identifier type, juce::ValueTree tree);</code></li>
</ul>
<ol type="1">
<li>If the <code>state</code> or <code>tree</code> argument is of type <code>type</code>, wrap that inside the object being created.</li>
<li>If the <code>state</code> or <code>tree</code> arguments has a child of type <code>type</code>, wrap that child inside the object beng created.</li>
<li>Else, we create a new ValueTree of type <code>type</code> and initialize it as appropriate. If the <code>state</code> arg was not null (or the <code>tree</code> is valid), add this new tree as a child.</li>
</ol>
<p>It is sometimes useful to know whether a new Object was created or wrapped &mdash; for example, it might be an error in your application if a child that's expected to be present isn't.</p>
<p>You can test this at runtime using the method <code>Object::getCreationType()</code>, which will return either:</p><ul>
<li><code>Object::CreationType::initialized</code></li>
<li><code>Object::CreationType::wrapped</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Working with Children</h2>
<p>ValueTrees can contain other ValueTrees as children, and it's important to keep in mind that there are two different modes for this containment:</p>
<ul>
<li><em>Heterogeneous</em> The parent tree is a data structure that contains other (tree) data structures. Access the children by specifying their type. The children are stored in a list, but the sequence is not significant.</li>
<li><em>Homogeneous</em> The parent tree contains a list of child trees, typically but not necessarily of the same type. Access the children by their index or iterating through them.</li>
</ul>
<p>There's no mechanism to enforce this distinction &mdash; if a list of different types makes sense in your application, there's a little more logic you'll need to write, but that's all.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Adding Children</h3>
<p><code>void append (Object* object);</code> adds the child to the end of this object's child list.</p>
<p><code>void insert (Object* object, int index);</code> adds the child at a specific index in the list; if <code>index</code> is out of range (less than zero or greater than the current number of children), the child will be appended to the list.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Removing Children</h3>
<p>To remove a child that's already wrapped in an Object, use</p>
<div class="fragment"><div class="line">Object* remove (Object* <span class="keywordtype">object</span>);</div>
</div><!-- fragment --><p>On success, this will return the same pointer you passed it; if that Object was not actually a child of this object, will return <code>nullptr</code>.</p>
<p>To remove a child by its index:</p>
<div class="fragment"><div class="line">juce::ValueTree remove (<span class="keywordtype">int</span> index);</div>
</div><!-- fragment --><p>This will return the raw ValueTree used by that child on success, or an invalid ValueTree on failure.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Finding Children</h3>
<p>We provide an <code>operator[]</code> to access children by their index:</p>
<div class="fragment"><div class="line">juce::ValueTree operator[] (<span class="keywordtype">int</span> index) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>You can also iterate through an Object's children:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> childTree: someObject)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// work with the raw ValueTree here, maybe using it to instantiate an object...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Moving / Sorting Children</h3>
<p>You can change the position of an individual child using the method</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> move (<span class="keywordtype">int</span> fromIndex, <span class="keywordtype">int</span> toIndex);</div>
</div><!-- fragment --><p>...and sort all the children with the method:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparator&gt; </div>
<div class="line"><span class="keywordtype">void</span> sort (Comparator&amp; comp, <span class="keywordtype">bool</span> stableSort);</div>
</div><!-- fragment --><p>where <code>Comparator</code> is an object that contains a method </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (<span class="keyword">const</span> ValueTree&amp; first, <span class="keyword">const</span> ValueTree&amp; second);</div>
</div><!-- fragment --><p>that returns</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>The <code>stableSort</code> argument specifies whether the sort algorithm should guarantee that equivalent children remain in their original order after the sort.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Undo/Redo</h2>
<p>Most ValueTree operations accept a pointer to a <code>juce::UndoManager</code> object as an argument to make those operations undoable/redoable. <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>s can maintain this manager for you: pass a pointer to <code>UndoManager</code> to a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> using its <code>setUndoManager</code> method, and that object and any child/descendant objects that are added to it will become undoable.</p>
<p>The following undo/redo methods are available directly from <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>:</p>
<ul>
<li><code>bool canUndo () const;</code></li>
<li><code>bool undo ();</code></li>
<li><code>bool canRedo () const;</code></li>
<li><code>bool redo ();</code></li>
<li><code>void clearUndoHistory ();</code></li>
</ul>
<p>You can also retrieve a pointer to the UndoManager (using <code>juce::UndoManager* getUndoManager()</code>) for any of its other operations that we don't expose directly.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Change Callbacks</h2>
<p>The <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> class defines a set of <code>std::function</code>s that can be installed as callbacks to be executed when properties or children of an object are changed:</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Property Changes</h3>
<p><code>PropertyUpdateFn</code> signature: <code>std::function&lt;void(juce::Identifier)&gt;</code></p>
<p>You can register a callback for each named property of an object that will be executed when the value of that property is changed. You can also register a wildcard callback using the identifier of the object itself that will be called when an attribute changes but there was no specific handler for it.</p>
<p>There are two Object methods to register these callbacks:</p>
<ul>
<li><code>void onPropertyChange (juce::Identifier id, PropertyUpdateFn callback)</code> &mdash; pass in the identifier of the attribute to watch</li>
<li><code>void onPropertyChange (const ValueBase&amp; val, PropertyUpdateFn callback);</code> &mdash; pass in a reference to the <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> or <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> to watch.</li>
</ul>
<h3><a class="anchor" id="autotoc_md19"></a>
Child Changes</h3>
<p>Changes to children are broadcast using a <code>ChildUpdateFn</code> callback that has the signature <code>std::function&lt;void (juce::ValueTree&amp; child, int oldIndex, int newIndex)&gt;;</code></p>
<ul>
<li><code>onChildAdded</code> &mdash; <code>oldIndex</code> will be -1, <code>newIndex</code> will be the index of the new child.</li>
<li><code>onChildRemoved</code> &mdash; <code>oldIndex</code> will be the index of the child that was removed, <code>newIndex</code> will be -1.</li>
<li><code>onChildMoved</code> &mdash; <code>oldIndex</code> and <code>newIndex</code> are self-explanatory.</li>
</ul>
<h3><a class="anchor" id="autotoc_md20"></a>
Tree Changes</h3>
<p>A <code>SelfUpdateFn</code> callback with the signature <code>std::function&lt;void (void)&gt;</code> will be called when:</p>
<ul>
<li><code>onParentChanged</code> &mdash; this object has been adopted by a different parent tree.</li>
<li><code>onTreeRedirected</code> &mdash; the underlying value tree used by this object was replaced with a different one.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
"Pythonesque" access</h2>
<p>Not everything can or should be done with the kind of compile-time API <code>cello</code> was written to support. These methods take their names and inspriation from similar methods in the Python object model.</p>
<p>These methods do provide some level of type-safety and type-coercion using <code>VariantConverter</code>s that our <code>Value</code> types have.</p>
<ul>
<li><code>bool hasattr (const juce::Identifier&amp; attr) const</code> tests an object to see if it has an attribute/property of the specified type (enabling what the Python world would call 'Look Before You Leap' programming)</li>
<li><code>template &lt;typename T&gt; Object&amp; setattr (const juce::Identifier&amp; attr, const T&amp; attrVal);</code> sets the value of the specified attribute in the object. We return a reference to the current Object so that multiple calls to this method can be chained together.</li>
<li><code>template &lt;typename T&gt; T getattr (const juce::Identifier&amp; attr, const T&amp; defaultVal) const</code> either returns the current value of the specified attribute, or a default value if it's not present.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
Persistence</h2>
<p><code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> instances can be persisted to or from disk in any of the three formats that ValueTrees support:</p><ul>
<li>text/XML</li>
<li>(JUCE proprietary) binary</li>
<li>binary, compressed with GZIP.</li>
</ul>
<p>To save a file, use the <code>bool save (juce::File file, FileFormat format = FileFormat::xml) const</code> method, which will write out that tree and all its descendants into the specified file.</p>
<p>Loading a file is a little more complex; we use a static method <code>static juce::ValueTree load (juce::File file, FileFormat format = FileFormat::xml)</code> that attempts to load and return a ValueTree from the specified file; you should then pass that ValueTree (if valid) to the constructor of your application's root Object type and verify that the constructor was able to wrap the tree it was given, code like:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> juce::File filePath { <span class="stringliteral">&quot;/path/to/my/file.xml&quot;</span> };</div>
<div class="line"><span class="keyword">auto</span> loadedTree { <a class="code hl_function" href="classcello_1_1_object.html#ad05bcbdf54e3587a9060dba4caeba462">cello::Object::load</a>(filePath) };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (! loadedTree.isValid ())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// failed to load the expected file. Maybe this is an error in your app?</span></div>
<div class="line">    <span class="comment">// if so, handle it! </span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyRootObject root { loadedTree };</div>
<div class="line"><span class="keywordflow">if</span> (root.getCreationType () == cello::Object::CreationType::initialized)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// we didn&#39;t load successfully -- if this is an error in your app, </span></div>
<div class="line">    <span class="comment">// handle it. </span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// else, we&#39;ve re-loaded -- carry on! </span></div>
<div class="ttc" id="aclasscello_1_1_object_html_ad05bcbdf54e3587a9060dba4caeba462"><div class="ttname"><a href="classcello_1_1_object.html#ad05bcbdf54e3587a9060dba4caeba462">cello::Object::load</a></div><div class="ttdeci">static juce::ValueTree load(juce::File file, FileFormat format=FileFormat::xml)</div><div class="ttdoc">Reload data from disk. Used in the ctor that accepts file name and format.</div><div class="ttdef"><b>Definition:</b> cello_object.cpp:259</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Missing Pieces</h1>
<p>There are parts of the <code>juce::ValueTree</code> API that are not available through the <code>cello</code> API; these may be added later, or you can use them directly by accessing the <code>ValueTree</code> object that an <code>Object</code> already owns.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Unit Tests</h1>
<p>There is a <a href="https://github.com/bgporter/cello_test">separate repo</a> containing a small unit test runner; you can also add my <a href="https://github.com/bgporter/testSuite">testSuite</a> JUCE module as a component in your application to execute the tests in your own app.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Release Notes</h1>
<h2><a class="anchor" id="autotoc_md26"></a>
Release 1.0.1 * 05 Feb 2023</h2>
<ul>
<li>added MIT license text to all source files.</li>
<li>added <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a> CSS/etc to document generation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Release 1.0.0 * 01 Jan 2023</h2>
<p>Original release. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
