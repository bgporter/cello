<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cello: Cello</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="cello_cello.png"/></td>
  <td id="projectalign">
   <div id="projectname">cello
   </div>
   <div id="projectbrief">JUCE ValueTrees for Humans</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Cello</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md19"></a> Classes for working with juce ValueTree objects.</p>
<p><b>Brett g Porter</b> * <a href="#" onclick="location.href='mai'+'lto:'+'bre'+'tt'+'@bg'+'po'+'rte'+'r.'+'net'; return false;">brett<span class="obfuscator">.nosp@m.</span>@bgp<span class="obfuscator">.nosp@m.</span>orter<span class="obfuscator">.nosp@m.</span>.net</a></p>
<p>API docs available <a href="https://bgporter.github.io/cello/">here</a></p>
<h1><a class="anchor" id="autotoc_md20"></a>
tl;dr</h1>
<p><code>Cello</code> is a set of C++ classes to work with <a href="https://docs.juce.com/master/classValueTree.html"><code>ValueTree</code></a> objects from the <a href="https://juce.com">JUCE</a> application framework.</p>
<p>This project has several overlapping goals:</p><ul>
<li>make working with ValueTrees more like working with C++ objects and less like calling API functions</li>
<li>explore the gray area between compile-time strong typing as in C++ and the kind of runtime dynamic typing that's possible using the ValueTree API</li>
<li>explore the available methods of reactive programming enabled with this system</li>
<li>build out new functionality that's implied by the capabilities of ValueTrees but perhaps not obvious, like:<ul>
<li>creating a kind of NoSQL database</li>
<li>creating a simple IPC implementation</li>
</ul>
</li>
<li>In general, add support for more complex use cases where the complexity can be hidden inside the framework.</li>
</ul>
<p>A new <code>Value</code> type provides type safety (including transparent conversion from arbitrary C++ types and the JUCE <code>var</code> type used within ValueTrees), optional validator functions called on set/get, and implementation of all the in-place arithmetic operators (for numeric types).</p>
<p>Additional support classes to safely use ValueTrees across thread and process boundaries (including over TCP connections and named pipes) simplify those use cases.</p>
<p>The design of the classes also simplifies the implementation of applications where the internals can be both loosely and dynamically coupled together using a super fine-grained implementation of the Observer pattern to support a reactive programming style.</p>
<p>The <code>Object</code> type:</p>
<ul>
<li>manages undo/redo for the object and all its children</li>
<li>provides a rich set of notification callbacks with no boilerplate required</li>
<li>provides persistence of the object and its children to/from disk</li>
<li>implements database-like query, sort, and update functionality</li>
<li>exposes (semi-typesafe) access to ValueTree properties whether they're represented by a <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> or not, in a Pythonesque manner.</li>
<li>provides access to the underlying ValueTree so you can use API functions not provided by the <code>cello</code> interface.</li>
</ul>
<p><code>Cello</code> is released under the terms of the <a href="https://opensource.org/license/mit/">MIT license</a>.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Acknowledgements</h2>
<ul>
<li>This project was largely written in response/reaction to a similar set of classes originally written by Chris Roberts, aka <code>cpr2323</code>, used in products we worked on together at Artiphon.</li>
<li>Those classes have over time seen modifications and refinements added by coworkers there including Vincent Berthiaume, JoÃ«l Langlois, Megan Jurek, Walter Kopacz, and Sean Maloney.</li>
<li>David Rowland's <a href="https://www.youtube.com/watch?v=3IaMjH5lBEY">presentation on Value Trees</a> from ADC'17 remains probably the best overview of the capabilities of the API itself</li>
<li>Matt Gonzalez from ECHO Audio tried to convince me long ago of the utility of ValueTrees, but I hadn't quite learned to trust his recommendations as quickly and deeply as I have since then.</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Motivation and Overview</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Confessions of a <code>ValueTree</code> Skeptic</h2>
<p>I've been using the JUCE framework for over a decade now, but there's a major component of JUCE that never clicked for me as a developer &mdash; ValueTrees. This wasn't a problem for me until I changed jobs and started needing to work on a mature codebase that made significant use of them. This code makes efforts to hide some of the more cumbersome or repetitive aspects of integrating ValueTrees into an application, but that <code>ValueTreeWrapper</code> class still seemed like it required too much effort to work with; where I'm used to thinking in terms of objects that contain values, any time I needed to get near data that's stored in a ValueTree, it was impossible to avoid the awareness that I was always working through an API to perform operations on data that should just be directly manipulable, and while the wrapper class approach mitigated this to some extent, there was still more boilerplate code to write than seems good to me, as well as other places where the gaps around the abstraction were more obvious than I like.</p>
<p>I've always found that the only way for me to work through these kinds of issues when I encounter them is to sit down with a blank document in an editor and start enumerating the problems that I see with a system and use that as a guide to start thinking about ways that I can engineer around the parts that aren't my favorite, and sometimes how I can reframe my thinking to start seeing superpowers where I thought there were deficiencies.</p>
<p>One of my current teammates has expressed confusion that I wasn't immediately on board with ValueTrees, and his defense of them was key to my eventually starting this re-analysis. They give you:</p>
<ul>
<li>A really easy way to capture and pass around the entire state of your application's data at run time</li>
<li>A rich mechanism to watch that data at a fine degree of granularity</li>
<li>Trivially easy persistence of application state</li>
</ul>
<p>...but at the cost (in comparison to using native POD or class/struct variables) of being:</p><ul>
<li>slower</li>
<li>less convenient to use</li>
<li>less type-safe, since all values are stored in the JUCE <code>var</code> variant type.</li>
</ul>
<p>As I started listing the tradeoffs, I considered ways to work around the convenience and type-safety issues. I also reflected on the years in my career when I wrote far more Python code than I did C++, and many of these same charges can be filed against that language, which I love.</p>
<p>At one level, you can look at Python as being nothing but a bunch of associative arrays (or in python, <code>dict</code>s) with the ability to be manipulated dynamically by code. Once I started thinking in those terms, the project became much more interesting.</p>
<p>As frequently happens with me, these thoughts sat collecting dust in a document until I hit upon a name for the project &mdash; <code>cello</code>, short for 'cellophane' (since the code is wrapping a ValueTree)</p>
<h2><a class="anchor" id="autotoc_md24"></a>
cello</h2>
<p>In short, my goal was: create a set of C++ classes that I can derive my own classes from where member variables are stored transparently in JUCE ValueTrees instead of directly in those object instances, combining the comfort and simplicity of working with normal-looking C++ code with the benefits and tradeoffs of ValueTrees.</p>
<p>Something similar to:</p>
<div class="fragment"><div class="line"><span class="comment">// define a struct with two members and then create an instance</span></div>
<div class="line"><span class="keyword">struct </span>CelloDemo : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// we&#39;ll figure this `Value` type out shortly...</span></div>
<div class="line">    <span class="comment">// we&#39;ll figure this `Value` type out shortly...</span></div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x;</div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;float&gt;</a> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">CelloDemo demoObject;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// give that object a lambda to call whenever the value of `x` changes. </span></div>
<div class="line">demoObject.onPropertyChange(demoObject.x, [&amp;demoObject] () </div>
<div class="line">{ </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;x changed to &quot;</span> &lt;&lt; demoObject.x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after executing this line, stdout should print: &quot;x changed to 100&quot;</span></div>
<div class="line">demoObject.x = 100;</div>
<div class="ttc" id="aclasscello_1_1_object_html"><div class="ttname"><a href="classcello_1_1_object.html">cello::Object</a></div><div class="ttdef"><b>Definition</b> cello_object.h:34</div></div>
<div class="ttc" id="aclasscello_1_1_value_html"><div class="ttname"><a href="classcello_1_1_value.html">cello::Value</a></div><div class="ttdoc">A class to abstract away the issues around storing and retrieving a value from a ValueTree....</div><div class="ttdef"><b>Definition</b> cello_value.h:68</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md25"></a>
Values</h1>
<ul>
<li>actually, a proxy to a value. We store a <code>juce::Identifier</code> and a reference to a ValueTree that provides the actual storage; storing or retrieving the value through its variable needs to do so through the ValueTree API, but that's all kept out of sight.</li>
<li>templated on an underlying data type to hide the fact that we're working with <code>juce::var</code> objects internally. <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> objects remove concerns about type-safety that <code>var</code>s introduce.</li>
<li>can be set to always update their listeners when the value is set, even if the underlying value wasn't changed.</li>
<li>can be given validator functions that will be called when the value is set or retrieved.</li>
<li>arithmetic types have all of the in-place operators (<code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>) defined.</li>
<li>can be used to access any C++ value data type for which a <code>juce::VariantConverter</code> struct has been defined.</li>
</ul>
<p><code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> objects only make sense as members of a class derived from <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> (below). The signature of the Value constuctor is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Value::Value (Object&amp; <span class="keywordtype">object</span>, <span class="keyword">const</span> juce::Identifier&amp; <span class="keywordtype">id</span>, T initVal);</div>
</div><!-- fragment --><p>...so at creation time, a value knows:</p><ol type="1">
<li>the Object holding a ValueTree where its storage is located</li>
<li>the identifier of this piece of data in the value tree</li>
<li>how to initialize that data if needed</li>
<li>The data type to use outside of the ValueTree. Because we use the <code>VariantConverter</code> facility in JUCE, almost any type of data can be converted to/from the <code>var</code> variant type.</li>
</ol>
<p>So, declaring an instance of this type templated on <code>int</code> as a member of a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> object would look like</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x { *<span class="keyword">this</span>, <span class="stringliteral">&quot;x&quot;</span>, {} };</div>
</div><!-- fragment --><p>We pass a reference to the owning object, the ID to use, and its default initial value. By convention, we use the same name for the member variable as for its Identifier in the ValueTree.</p>
<p>We define a macro in <code><a class="el" href="cello__value_8h_source.html">cello_value.h</a></code> that's less cumbersome and less potentially error-prone to do the same thing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAKE_VALUE_MEMBER(type, name, init) \</span></div>
<div class="line"><span class="preprocessor">    cello::Value&lt;type&gt; name { *this, #name, init };</span></div>
</div><!-- fragment --><p>...so the above declaration would be <code>MAKE_VALUE_MEMBER (int, x, {});</code>. Once a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> containing this declaration is instantiated, you can manipulate that value almost exactly the same as if it were an actual instance of the underlying type ("almost exactly" here covers edge cases like <code>sizeof</code> giving different results, and probably others that I haven't considered yet):</p>
<div class="fragment"><div class="line"><span class="comment">// after each of these lines, any property change callbacks watching </span></div>
<div class="line"><span class="comment">// `x` will be called. </span></div>
<div class="line">myObj.x = 20;</div>
<div class="line">--myObj.x;</div>
<div class="line">myObj.x *= -3;</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md26"></a>
VariantConverters</h2>
<p>By defining a template specialization of the <code>juce::VariantConverter</code> struct, you can store more complex value types by cleverly packing them inside one of the more interesting <code>var</code> variants that exist &mdash; in this example from the <code>cello</code> unit tests, we use the fact that an <code>Array</code> of <code>var</code>s is a <code>var</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>juce</div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>VariantConverter&lt;std::complex&lt;float&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> std::complex&lt;float&gt; fromVar (<span class="keyword">const</span> var&amp; v)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* array = v.getArray (); array != <span class="keyword">nullptr</span> &amp;&amp; array-&gt;size () == 2)</div>
<div class="line">            <span class="keywordflow">return</span> { array-&gt;getUnchecked (0), array-&gt;getUnchecked (1) };</div>
<div class="line">        jassertfalse;</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> var toVar (<span class="keyword">const</span> std::complex&lt;float&gt;&amp; val)</div>
<div class="line">    {</div>
<div class="line">        Array&lt;var&gt; array;</div>
<div class="line">        array.set (0, val.real ());</div>
<div class="line">        array.set (1, val.imag ());</div>
<div class="line">        <span class="keywordflow">return</span> { std::move (array) };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace juce</span></div>
</div><!-- fragment --><p>Then we define a class that has a single public Value member that contains a <code>std::complex&lt;float&gt;</code> &mdash; there's no additional work required to perform the conversions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ObjectWithConvertibleValue : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ObjectWithConvertibleValue ()</div>
<div class="line">    : cello::Object (<span class="stringliteral">&quot;convertible&quot;</span>, nullptr)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the `complexVal` member can be used as a `std::complex&lt;float&gt;`; the </span></div>
<div class="line">    <span class="comment">// round-tripping through a juce::var is completely hidden. </span></div>
<div class="line">    MAKE_VALUE_MEMBER (std::complex&lt;float&gt;, complexVal, {});</div>
<div class="line">};</div>
</div><!-- fragment --><p>Your code is then free to work with that value directly:</p>
<div class="fragment"><div class="line">ObjectWithConvertibleValue o;</div>
<div class="line">std::complex&lt;float&gt; orig { 2.f, 3.f };</div>
<div class="line">o.complexVal = orig;</div>
<div class="line"> </div>
<div class="line">std::complex&lt;float&gt; retrieved { o.complexVal };</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.real (), retrieved.real (), 0.001f);</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.imag (), retrieved.imag (), 0.001f);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Validator Functions</h2>
<p>If we're taking some inspiration from Python here, it's worth remembering that Python developers are in the practice of leaving all their class member variables public instead of hiding them behind a wall of privacy and forcing the usage of <code>getVariable()</code>/<code>setVariable()</code> methods to ensure the separation of interface from implementation&mdash;much of the time, there's no reason to require those accessor/mutator methods, and when there is an actual reason (for example, to ensure the maintenance of a class invariant), it's easy to switch over to using a property to manage access to the underlying data. Bertrand Meyer, creator of the Eiffel programming language refers to this as the "Uniform Access Principle," that _"...all services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation."_</p>
<p>Each <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> object may have <code>ValidatePropertyFn</code> lambdas assigned to it (where that lambda accepts a const reference to <code>T</code> and returns a <code>T</code> by value) that are (<code>onSet</code>) called before that value is stored into the underlying ValueTree or (<code>onGet</code>) called after retrieving the property from the ValueTree but before returning the value to calling code.</p>
<p>Your application can use this facility to modify the value (e.g. to keep it within a valid range), create an entirely new value, make changes to other properties of the ValueTree, create log entries, or anything else that you need to happen at these juncture points.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Caching values</h2>
<p>There will be times when a value stored in a ValueTree/Object needs to be used frequently enough that the overhead of re-fetching from the underlying tree and performing validation on it become problematic. The <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a>::&lt;T&gt;::Cached</code> class provides a simple mechanism to maintain a copy of a Value object that's automatically updated each time it changes.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Forcing Update Callbacks</h2>
<p>The normal behavior of ValueTrees is to only notify callback listeners of property changes when a value actually <em>changes</em>. In practice, it's frequently useful to ensure that any attempt to set a property results in notifications being sent even if setting it to its current value. This can be controlled on a per-value basis by calling that value's <code>forceUpdate (bool shouldForceUpdate)</code> method.</p>
<p>To simplify the common case where this behavior is only meant to be in force for a single update, we provide a utility class <code>ScopedForceUpdater</code> that sets the value to force sending updates when the class is constructed, and then clears the update logic when that updater object goes out of scope.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Excluding Listeners</h2>
<p>It's also common to want to send update callbacks to all listeners except one&mdash;for example, if I have a bit of code that's setting a value and that code is also listening to the value, there's no need to receive a callback; that code already knows what the new value is. The <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> class provides a method <code>void excludeListener (juce::ValueTree::Listener* listener)</code> for this purpose.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Objects</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Creation Patterns: Creating vs Wrapping</h2>
<p>Since our objects rely on separate ValueTree objects for their storage, we need to support two different mechanisms for creating instances:</p>
<ol type="1">
<li>If the ValueTree doesn't exist yet, we need to create one and initialize it for use.</li>
<li>When the value tree already exists, we need to 'wrap' it to access its storage and capabilities.</li>
</ol>
<p>The constructors of <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> handle both these cases for us, using the logic outlined below:</p>
<ul>
<li><code>Object (const juce::String&amp; type, Object* state);</code> (preferred)</li>
<li><code>Object (const juce::String&amp; type, Object&amp; state);</code> (preferred)</li>
<li><code>Object (const juce::String&amp; type, juce::ValueTree tree);</code></li>
</ul>
<ol type="1">
<li>If the <code>state</code> or <code>tree</code> argument is of type <code>type</code>, wrap that inside the object being created.</li>
<li>If the <code>state</code> or <code>tree</code> arguments has a child of type <code>type</code>, wrap that child inside the object beng created.</li>
<li>Else, we create a new ValueTree of type <code>type</code> and initialize it as appropriate. If the <code>state</code> arg was not null (or the <code>tree</code> is valid), add this new tree as a child.</li>
</ol>
<p>It is sometimes useful to know whether a new Object was created or wrapped &mdash; for example, it might be an error in your application if a child that's expected to be present isn't.</p>
<p>You can test this at runtime using the method <code>Object::getCreationType()</code>, which will return either:</p><ul>
<li><code>Object::CreationType::initialized</code></li>
<li><code>Object::CreationType::wrapped</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Creating/Finding Objects in a Hierarchy</h2>
<p>The <code>type</code> argument to an Object constructor can be richer than just a simple <code>juce::Identifier</code>; it's useful in an application to be able to pass around a single top-level context object and have individual objects within that hierarchy be able to find themselves.</p>
<p>Consider a common pattern where an application needs to have separate trees to collect persistent attributes that are saved and restored between app runs, and another that holds runtime values that are recreated each time the application runs. Rather than write procedural code to start at the root and find (or create) individual child objects that are expected, we can do the same thing declaratively using paths, like: <code>/persistent/object1/object2</code>, which would start at the root tree, then descend through children <code>persistent</code>, <code>object1</code>, and <code>object2</code>, creating any children that are not found.</p>
<p>Path elements are separated with forward slashes.</p>
<p>If the first character in a path string is <code>/</code>, the path is absolute starting at the root.</p>
<p>All other paths are relative to the Object that's passed into an Object constructor.</p>
<p>Path elements starting with a circumflex character <code>^</code> will search upward from the current path location to find an ancestor Object of a specified type, so <code>^grandpa</code> is read as "search upward in the hierarchy from the current path location until you find an object of type `grandpa`".</p>
<p>A path element of <code>..</code> operates as it does in file systems, navigating to the parent of the current path location, so <code>../sibling</code> would find a sibling object of the current one, and <code>../../uncle</code> will look for a sibling of the current object's parent.</p>
<p>All other paths must be valid <code>juce::Identifier</code>s, and search downward through child objects.</p>
<p>Downward searches when instantiating <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>s will create child trees (that will <em>not</em> be initialized) as needed.</p>
<p>Searches upward from an object will not be able to create interim object/trees. You can check the <code>CreationType</code> after the constructor executes to make sure that you have a valid object before using it. You can test for existence before attempting creation by instantiating a <code><a class="el" href="classcello_1_1_path.html" title="Class to navigate between subtrees that are all connected together.">cello::Path</a></code> object directly and using its <code>findValueTree()</code> method with a search type of <code>Query</code>; if that search returns an invalid <code>juce::ValueTree</code>, you'll need to handle that case as appropriate, whether it's an error, or just triggers additional configuration/creation of the hierarchy before using it.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Working with Children</h2>
<p>ValueTrees can contain other ValueTrees as children, and it's important to keep in mind that there are two different modes for this containment:</p>
<ul>
<li><em>Heterogeneous</em> The parent tree is a data structure that contains other (tree) data structures. Access the children by specifying their type. The children are stored in a list, but the sequence is not significant.</li>
<li><em>Homogeneous</em> The parent tree contains a list of child trees, typically but not necessarily of the same type. Access the children by their index or iterating through them.</li>
</ul>
<p>There's no mechanism to enforce this distinction&mdash;if a list of different types makes sense in your application, there's a little more logic you'll need to write, but that's all.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Adding Children</h3>
<p><code>void append (Object* object);</code> adds the child to the end of this object's child list.</p>
<p><code>void insert (Object* object, int index);</code> adds the child at a specific index in the list; if <code>index</code> is out of range (less than zero or greater than the current number of children), the child will be appended to the list.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
Removing Children</h3>
<p>To remove a child that's already wrapped in an Object, use</p>
<div class="fragment"><div class="line">Object* remove (Object* <span class="keywordtype">object</span>);</div>
</div><!-- fragment --><p>On success, this will return the same pointer you passed it; if that Object was not actually a child of this object, will return <code>nullptr</code>.</p>
<p>To remove a child by its index:</p>
<div class="fragment"><div class="line">juce::ValueTree remove (<span class="keywordtype">int</span> index);</div>
</div><!-- fragment --><p>This will return the raw ValueTree used by that child on success, or an invalid ValueTree on failure.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
Finding Children</h3>
<p>We provide an <code>operator[]</code> to access children by their index:</p>
<div class="fragment"><div class="line">juce::ValueTree operator[] (<span class="keywordtype">int</span> index) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>You can also iterate through an Object's children:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> childTree: someObject)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// work with the raw ValueTree here, maybe using it to instantiate an object...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md38"></a>
Moving / Sorting Children</h3>
<p>You can change the position of an individual child using the method</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> move (<span class="keywordtype">int</span> fromIndex, <span class="keywordtype">int</span> toIndex);</div>
</div><!-- fragment --><p>...and sort all the children with the method:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparator&gt; </div>
<div class="line"><span class="keywordtype">void</span> sort (Comparator&amp; comp, <span class="keywordtype">bool</span> stableSort);</div>
</div><!-- fragment --><p>where <code>Comparator</code> is an object that contains a method </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (<span class="keyword">const</span> ValueTree&amp; first, <span class="keyword">const</span> ValueTree&amp; second);</div>
</div><!-- fragment --><p>that returns</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>The <code>stableSort</code> argument specifies whether the sort algorithm should guarantee that equivalent children remain in their original order after the sort.</p>
<p>After <code>cello</code> release 1.1, you may wish to instead use the new database/query features for searching and sorting.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Database / Query</h2>
<p>Use the <code><a class="el" href="classcello_1_1_query.html">cello::Query</a></code> object to define a set of search and sort criteria to use to perform simple database-like operations. Instead of defining a query language, we've defined two function types that can be passed into a Query object to define its behavior at run time:</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Query::Predicate</h3>
<div class="fragment"><div class="line"><span class="comment">// query function, returns true if the tree it is passed should</span></div>
<div class="line"><span class="comment">// be included in the result set.</span></div>
<div class="line"><span class="keyword">using </span>Predicate = std::function&lt;bool (juce::ValueTree)&gt;;</div>
<div class="line"> </div>
<div class="line">Query&amp; addFilter (Predicate filter);</div>
</div><!-- fragment --><p>You can specify any number of predicate functions for a Query object to use; these functions accept a ValueTree as an argument and return a boolean to indicate whether this child tree should be included in the query search results.</p>
<p>The search logic will execute these functions in the order they were added until encountering one that returns <code>false</code>. If all of the query predicates return <code>true</code>, a copy of this ValueTree will be added to the search results.</p>
<p>If a query is run with no predicate functions defined, all children of the <code>Object</code> being searched will be copied and added to the search results.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
Query::Comparison</h3>
<div class="fragment"><div class="line"><span class="comment">// comparison/sort function.</span></div>
<div class="line"><span class="comment">// return 0 if the two trees should sort equally.</span></div>
<div class="line"><span class="comment">// return -1 if left should come before right</span></div>
<div class="line"><span class="comment">// return +1 if right should come before left.</span></div>
<div class="line"><span class="keyword">using </span>Comparison = std::function&lt;int (<span class="keyword">const</span> juce::ValueTree&amp;, <span class="keyword">const</span> juce::ValueTree&amp;)&gt;;</div>
<div class="line"> </div>
<div class="line">Query&amp; addComparison (Comparison sorter);</div>
</div><!-- fragment --><p>You can also specify comparison functions that will be used to sort the results list after a query is performed; if none are provided, the items in the search results will be in the same order they exist in the <code>Object</code> being queried.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Object::find</h3>
<div class="fragment"><div class="line"> </div>
<div class="line">juce::ValueTree find (<span class="keyword">const</span> <a class="code hl_class" href="classcello_1_1_query.html">cello::Query</a>&amp; query, <span class="keywordtype">bool</span> deep = <span class="keyword">false</span>);</div>
<div class="ttc" id="aclasscello_1_1_query_html"><div class="ttname"><a href="classcello_1_1_query.html">cello::Query</a></div><div class="ttdef"><b>Definition</b> cello_query.h:28</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md43"></a>
Object::upsert and Object::upsertAll</h3>
<p>These use a concept borrowed from the MongoDB NoSql database; an 'upsert` operation performs one of:</p><ul>
<li>Update a record in place if possible</li>
<li>Otherwise, add (insert) a new record to the object.</li>
</ul>
<p>The main use case here would be to</p><ol type="1">
<li>Perform a query to get a list of (copies of) items</li>
<li>Modify those copies in the result list</li>
<li>Perform an upsert to apply the changes back into the original data.</li>
</ol>
<p>For this to work, your items must be defined such that each has a unique key value that can be used to link the update tree with the original one to be updated. In the unit tests for this function, our <code>Data</code> objects have an attribute <code>key</code> that is populated with a monotonically incremented integer when created. In production code, it would be better to use something more unique, like a <code>juce::Uuid</code>.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Undo/Redo</h2>
<p>Most ValueTree operations accept a pointer to a <code>juce::UndoManager</code> object as an argument to make those operations undoable/redoable. <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>s can maintain this manager for you: pass a pointer to <code>UndoManager</code> to a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> using its <code>setUndoManager</code> method, and that object and any child/descendant objects that are added to it will become undoable.</p>
<p>The following undo/redo methods are available directly from <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>:</p>
<ul>
<li><code>bool canUndo () const;</code></li>
<li><code>bool undo ();</code></li>
<li><code>bool canRedo () const;</code></li>
<li><code>bool redo ();</code></li>
<li><code>void clearUndoHistory ();</code></li>
</ul>
<p>You can also retrieve a pointer to the UndoManager (using <code>juce::UndoManager* getUndoManager()</code>) for any of its other operations that we don't expose directly.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Change Callbacks</h2>
<p>The <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> class defines a set of <code>std::function</code>s that can be installed as callbacks to be executed when properties or children of an object are changed:</p>
<h3><a class="anchor" id="autotoc_md46"></a>
Property Changes</h3>
<p><code>PropertyUpdateFn</code> signature: <code>std::function&lt;void(juce::Identifier)&gt;</code></p>
<p>You can register a callback for each named property of an object that will be executed when the value of that property is changed. You can also register a wildcard callback using the identifier of the object itself that will be called when an attribute changes but there was no specific handler for it.</p>
<p>There are two Object methods to register these callbacks:</p>
<ul>
<li><code>void onPropertyChange (juce::Identifier id, PropertyUpdateFn callback)</code> &mdash; pass in the identifier of the attribute to watch</li>
<li><code>void onPropertyChange (const ValueBase&amp; val, PropertyUpdateFn callback);</code> &mdash; pass in a reference to the <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> or <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> to watch.</li>
</ul>
<p>If the <code>Value</code> that you're watching is a public member of an <code>Object</code>, you can also subscribe to its updates directly using the method <code>Value&lt;T&gt;::onPropertyUpdate (PropertyUpdateFn callback);</code></p>
<h3><a class="anchor" id="autotoc_md47"></a>
Child Changes</h3>
<p>Changes to children are broadcast using a <code>ChildUpdateFn</code> callback that has the signature <code>std::function&lt;void (juce::ValueTree&amp; child, int oldIndex, int newIndex)&gt;;</code></p>
<ul>
<li><code>onChildAdded</code> &mdash; <code>oldIndex</code> will be -1, <code>newIndex</code> will be the index of the new child.</li>
<li><code>onChildRemoved</code> &mdash; <code>oldIndex</code> will be the index of the child that was removed, <code>newIndex</code> will be -1.</li>
<li><code>onChildMoved</code> &mdash; <code>oldIndex</code> and <code>newIndex</code> are self-explanatory.</li>
</ul>
<h3><a class="anchor" id="autotoc_md48"></a>
Tree Changes</h3>
<p>A <code>SelfUpdateFn</code> callback with the signature <code>std::function&lt;void (void)&gt;</code> will be called when:</p>
<ul>
<li><code>onParentChanged</code> &mdash; this object has been adopted by a different parent tree.</li>
<li><code>onTreeRedirected</code> &mdash; the underlying value tree used by this object was replaced with a different one.</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
"Pythonesque" access</h2>
<p>Not everything can or should be done with the kind of compile-time API <code>cello</code> was written to support. These methods take their names and inspriation from similar methods in the Python object model.</p>
<p>These methods do provide some level of type-safety and type-coercion using <code>VariantConverter</code>s that our <code>Value</code> types have.</p>
<ul>
<li><code>bool hasattr (const juce::Identifier&amp; attr) const</code> tests an object to see if it has an attribute/property of the specified type (enabling what the Python world would call 'Look Before You Leap' programming)</li>
<li><code>template &lt;typename T&gt; Object&amp; setattr (const juce::Identifier&amp; attr, const T&amp; attrVal);</code> sets the value of the specified attribute in the object. We return a reference to the current Object so that multiple calls to this method can be chained together.</li>
<li><code>template &lt;typename T&gt; T getattr (const juce::Identifier&amp; attr, const T&amp; defaultVal) const</code> either returns the current value of the specified attribute, or a default value if it's not present.</li>
</ul>
<h2><a class="anchor" id="autotoc_md50"></a>
Persistence</h2>
<p><code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> instances can be persisted to or from disk in any of the three formats that ValueTrees support:</p><ul>
<li>text/XML</li>
<li>(JUCE proprietary) binary</li>
<li>binary, compressed with GZIP.</li>
</ul>
<p>To save a file, use the <code>bool save (juce::File file, FileFormat format = FileFormat::xml) const</code> method, which will write out that tree and all its descendants into the specified file.</p>
<p>Loading a file is a little more complex; we use a static method <code>static juce::ValueTree load (juce::File file, FileFormat format = FileFormat::xml)</code> that attempts to load and return a ValueTree from the specified file; you should then pass that ValueTree (if valid) to the constructor of your application's root Object type and verify that the constructor was able to wrap the tree it was given, code like:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> juce::File filePath { <span class="stringliteral">&quot;/path/to/my/file.xml&quot;</span> };</div>
<div class="line"><span class="keyword">auto</span> loadedTree { <a class="code hl_function" href="classcello_1_1_object.html#ad05bcbdf54e3587a9060dba4caeba462">cello::Object::load</a>(filePath) };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (! loadedTree.isValid ())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// failed to load the expected file. Maybe this is an error in your app?</span></div>
<div class="line">    <span class="comment">// if so, handle it! </span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyRootObject root { loadedTree };</div>
<div class="line"><span class="keywordflow">if</span> (root.getCreationType () == cello::Object::CreationType::initialized)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// we didn&#39;t load successfully -- if this is an error in your app, </span></div>
<div class="line">    <span class="comment">// handle it. </span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// else, we&#39;ve re-loaded -- carry on! </span></div>
<div class="ttc" id="aclasscello_1_1_object_html_ad05bcbdf54e3587a9060dba4caeba462"><div class="ttname"><a href="classcello_1_1_object.html#ad05bcbdf54e3587a9060dba4caeba462">cello::Object::load</a></div><div class="ttdeci">static juce::ValueTree load(juce::File file, FileFormat format=FileFormat::xml)</div><div class="ttdoc">Reload data from disk. Used in the ctor that accepts file name and format.</div><div class="ttdef"><b>Definition</b> cello_object.cpp:285</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
Thread-safe Updates</h2>
<p>When working with multiple threads, it's important to ensure that when two threads work with the same piece of data that they do so using techniques that prevent the common problems when using threads&mdash;race conditions, data corruption, deadlocks, etc.</p>
<p><code>cello</code> provides the <code><a class="el" href="classcello_1_1_sync.html" title="Permits thread-safe Object updates by using the juce::ValueTreeSynchroniser class to generate small b...">cello::Sync</a></code> class to support clean updates across thread boundaries. We do this using a pair of <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code>s of the same underlying ValueTree type, letting the <code>juce::ValueTreeSynchroniser</code> object perform most of the hard work: when the 'producer' object is changed, it generates a small binary payload containing the deltas that need to be applied to the <code>consumer</code> object to make them sync up. Because all the operations are performed on the ValueTrees themselves, once a <code>Sync</code> object is created to connect the pair, your code doesn't need to concern itself over the origin of a change.</p>
<p><code><a class="el" href="classcello_1_1_sync.html" title="Permits thread-safe Object updates by using the juce::ValueTreeSynchroniser class to generate small b...">cello::Sync</a></code> objects are created with this constructor:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">Sync (Object&amp; producer, Object&amp; consumer, juce::Thread* thread);</div>
</div><!-- fragment --><p> To perform bidirectional sync operations, create a pair of <code>Sync</code> objects with the products/consumer roles swapped appropriately. You'll need to be careful when doing this to avoid creating feedback loops where updates echo infinitely between Objects.</p>
<p>When the consumer object is being updated on the message thread, the Sync class will handle executing the updates automatically for you. Consumers being updated in a worker thread will need to find a place in their <code>run()</code> loop to check for and execute any pending updates. A minimal worker thread class would look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>WorkerThread : <span class="keyword">public</span> juce::Thread</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    WorkerThread (<span class="keyword">const</span> juce::String&amp; name)</div>
<div class="line">    : juce::Thread (name)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setSync (<a class="code hl_class" href="classcello_1_1_sync.html">cello::Sync</a>* syncObject)</div>
<div class="line">    {</div>
<div class="line">        jassert (syncObject != <span class="keyword">nullptr</span>);</div>
<div class="line">        sync = syncObject;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> run ()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        jassert (sync != <span class="keyword">nullptr</span>);</div>
<div class="line">        <span class="keywordflow">while</span> (!threadShouldExit ())</div>
<div class="line">        {</div>
<div class="line">            sync-&gt;performAllUpdates ();</div>
<div class="line">            wait (1000);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_sync.html">cello::Sync</a>* sync;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscello_1_1_sync_html"><div class="ttname"><a href="classcello_1_1_sync.html">cello::Sync</a></div><div class="ttdoc">Permits thread-safe Object updates by using the juce::ValueTreeSynchroniser class to generate small b...</div><div class="ttdef"><b>Definition</b> cello_sync.h:83</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md52"></a>
Missing Pieces</h1>
<p>There are parts of the <code>juce::ValueTree</code> API that are not available through the <code>cello</code> API; these may be added later, or you can use them directly by accessing the <code>ValueTree</code> object that an <code>Object</code> already owns.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Unit Tests</h1>
<p>There is a <a href="https://github.com/bgporter/cello_test">separate repo</a> containing a small unit test runner; you can also add my <a href="https://github.com/bgporter/testSuite">testSuite</a> JUCE module as a component in your application to execute the tests in your own app.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Release Notes</h1>
<p>See <a class="el" href="md__c_h_a_n_g_e_l_o_g.html">CHANGELOG</a></p>
<h1><a class="anchor" id="autotoc_md55"></a>
License</h1>
<div class="fragment"><div class="line">Copyright (c) 2023 Brett g Porter</div>
<div class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</div>
<div class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</div>
<div class="line">in the Software without restriction, including without limitation the rights</div>
<div class="line">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</div>
<div class="line">copies of the Software, and to permit persons to whom the Software is</div>
<div class="line">furnished to do so, subject to the following conditions:</div>
<div class="line">The above copyright notice and this permission notice shall be included in all</div>
<div class="line">copies or substantial portions of the Software.</div>
<div class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</div>
<div class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</div>
<div class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</div>
<div class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</div>
<div class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</div>
<div class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</div>
<div class="line">SOFTWARE.</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
