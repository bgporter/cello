<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cello: Cello</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="cello_cello.png"/></td>
  <td id="projectalign">
   <div id="projectname">cello
   </div>
   <div id="projectbrief">Classes for working with JUCE ValueTrees</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Cello</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md16"></a> Classes for working with juce ValueTree objects.</p>
<p><b>Fall 2022 * Brett g Porter</b></p>
<p><a href="#" onclick="location.href='mai'+'lto:'+'bre'+'tt'+'@bg'+'po'+'rte'+'r.'+'net'; return false;">brett<span class="obfuscator">.nosp@m.</span>@bgp<span class="obfuscator">.nosp@m.</span>orter<span class="obfuscator">.nosp@m.</span>.net</a></p>
<p>API docs available <a href="https://bgporter.github.io/cello/">here</a></p>
<h1><a class="anchor" id="autotoc_md17"></a>
tl;dr</h1>
<p><code>Cello</code> is a set of C++ classes to work with <a href="https://docs.juce.com/master/classValueTree.html"><code>ValueTree</code></a> objects from the <a href="https://juce.com">JUCE</a> application framework.</p>
<p>The primary intent of this project is to make working with ValueTrees more like working with C++ objects and less like calling API functions.</p>
<p>A new <code>Value</code> type provides type safety (including transparent conversion from arbitrary C++ types and the JUCE <code>var</code> type used within ValueTrees), optional validator functions called on set/get, and implementation of all the in-place arithmetic operators (for numeric types).</p>
<p>The <code>Object</code> type:</p>
<ul>
<li>manages undo/redo for the object and all its children</li>
<li>provides a rich set of notification callbacks with no boilerplate required</li>
<li>provides persistence of the object and its children to/from disk</li>
<li>implements database-like query, sort, and update functionality</li>
<li>exposes (semi-typesafe) access to ValueTree properties whether they're represented by a <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> or not, in a Pythonesque manner.</li>
<li>provides access to the underlying ValueTree so you can use API functions not provided by the <code>cello</code> interface.</li>
</ul>
<p><code>Cello</code> is released under the terms of the <a href="https://opensource.org/license/mit/">MIT license</a>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Motivation and Overview</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Confessions of a &lt;tt&gt;ValueTree&lt;/tt&gt; Skeptic</h2>
<p>I've been using the JUCE framework for over a decade now, but there's a major component of JUCE that never clicked for me as a developer &mdash; ValueTrees. This wasn't a problem for me until I changed jobs and started needing to work on a mature codebase that made significant use of them. This code makes efforts to hide some of the more cumbersome or repetitive aspects of integrating ValueTrees into an application, but that <code>ValueTreeWrapper</code> class still seemed like it required too much effort to work with; where I'm used to thinking in terms of objects that contain values, any time I needed to get near data that's stored in a ValueTree, it was impossible to avoid the awareness that I was always working through an API to perform operations on data that should just be directly manipulable, and while the wrapper class approach mitigated this to some extent, there was still more boilerplate code to write than seems good to me, as well as other places where the gaps around the abstraction were more obvious than I like.</p>
<p>I've always found that the only way for me to work through these kinds of issues when I encounter them is to sit down with a blank document in an editor and start enumerating the problems that I see with a system and use that as a guide to start thinking about ways that I can engineer around the parts that aren't my favorite, and sometimes how I can reframe my thinking to start seeing superpowers where I thought there were deficiencies. I've always found that the only way for me to work through these kinds of issues when I encounter them is to sit down with a blank document in an editor and start enumerating the problems that I see with a system and use that as a guide to start thinking about ways that I can engineer around the parts that aren't my favorite, and sometimes how I can reframe my thinking to start seeing superpowers where I thought there were deficiencies.</p>
<p>One of my current teammates has expressed confusion that I wasn't immediately on board with ValueTrees, and his defense of them was key to my eventually starting this re-analysis. They give you:</p>
<ul>
<li>A really easy way to capture and pass around the entire state of your application's data at run time</li>
<li>A rich mechanism to watch that data at a fine degree of granularity</li>
<li>Trivially easy persistence of application state</li>
</ul>
<p>...but at the cost (in comparison to using native POD or class/struct variables) of being:</p><ul>
<li>slower</li>
<li>less convenient to use</li>
<li>less type-safe, since all values are stored in the JUCE <code>var</code> variant type.</li>
</ul>
<p>As I started listing the tradeoffs, I considered ways to work around the convenience and type-safety issues. I also reflected on the years in my career when I wrote far more Python code than I did C++, and many of these same charges can be filed against that language, which I love.</p>
<p>At one level, you can look at Python as being nothing but a bunch of associative arrays (or in python, <code>dict</code>s) with the ability to be manipulated dynamically by code. Once I started thinking in those terms, the project became much more interesting.</p>
<p>As frequently happens with me, these thoughts sat collecting dust in a document until I hit upon a name for the project &mdash; <code>cello</code>, short for 'cellophane' (since the code is wrapping a ValueTree)</p>
<h2><a class="anchor" id="autotoc_md20"></a>
cello</h2>
<p>In short, my goal was: create a set of C++ classes that I can derive my own classes from where member variables are stored transparently in JUCE ValueTrees instead of directly in those object instances, combining the comfort and simplicity of working with normal-looking C++ code with the benefits and tradeoffs of ValueTrees.</p>
<p>Something similar to:</p>
<div class="fragment"><div class="line"><span class="comment">// define a struct with two members and then create an instance</span></div>
<div class="line"><span class="keyword">struct </span>CelloDemo : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// we&#39;ll figure this `Value` type out shortly...</span></div>
<div class="line">    <span class="comment">// we&#39;ll figure this `Value` type out shortly...</span></div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x;</div>
<div class="line">    <a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;float&gt;</a> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">CelloDemo demoObject;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// give that object a lambda to call whenever the value of `x` changes. </span></div>
<div class="line">demoObject.onPropertyChange(demoObject.x, [&amp;demoObject] () </div>
<div class="line">{ </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;x changed to &quot;</span> &lt;&lt; demoObject.x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after executing this line, stdout should print: &quot;x changed to 100&quot;</span></div>
<div class="line">demoObject.x = 100;</div>
<div class="ttc" id="aclasscello_1_1_object_html"><div class="ttname"><a href="classcello_1_1_object.html">cello::Object</a></div><div class="ttdef"><b>Definition</b> cello_object.h:34</div></div>
<div class="ttc" id="aclasscello_1_1_value_html"><div class="ttname"><a href="classcello_1_1_value.html">cello::Value</a></div><div class="ttdoc">A class to abstract away the issues around storing and retrieving a value from a ValueTree....</div><div class="ttdef"><b>Definition</b> cello_value.h:68</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md21"></a>
Values</h1>
<ul>
<li>actually, a proxy to a value. We store a <code>juce::Identifier</code> and a reference to a ValueTree that provides the actual storage; storing or retrieving the value through its variable needs to do so through the ValueTree API, but that's all kept out of sight.</li>
<li>templated on an underlying data type to hide the fact that we're working with <code>juce::var</code> objects internally. <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> objects remove concerns about type-safety that <code>var</code>s introduce.</li>
<li>can be set to always update their listeners when the value is set, even if the underlying value wasn't changed.</li>
<li>can be given validator functions that will be called when the value is set or retrieved.</li>
<li>arithmetic types have all of the in-place operators (<code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>) defined.</li>
<li>can be used to access any C++ value data type for which a <code>juce::VariantConverter</code> struct has been defined.</li>
</ul>
<p><code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> objects only make sense as members of a class derived from <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> (below). The signature of the Value constuctor is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Value::Value (Object&amp; <span class="keywordtype">object</span>, <span class="keyword">const</span> juce::Identifier&amp; <span class="keywordtype">id</span>, T initVal);</div>
</div><!-- fragment --><p>...so at creation time, a value knows:</p><ol type="1">
<li>the Object holding a ValueTree where its storage is located</li>
<li>the identifier of this piece of data in the value tree</li>
<li>how to initialize that data if needed</li>
<li>The data type to use outside of the ValueTree. Because we use the <code>VariantConverter</code> facility in JUCE, almost any type of data can be converted to/from the <code>var</code> variant type.</li>
</ol>
<p>So, declaring an instance of this type templated on <code>int</code> as a member of a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> object would look like</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classcello_1_1_value.html">cello::Value&lt;int&gt;</a> x { *<span class="keyword">this</span>, <span class="stringliteral">&quot;x&quot;</span>, {} };</div>
</div><!-- fragment --><p>We pass a reference to the owning object, the ID to use, and its default initial value. By convention, we use the same name for the member variable as for its Identifier in the ValueTree.</p>
<p>We define a macro in <code><a class="el" href="cello__value_8h_source.html">cello_value.h</a></code> that's less cumbersome and less potentially error-prone to do the same thing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAKE_VALUE_MEMBER(type, name, init) \</span></div>
<div class="line"><span class="preprocessor">    cello::Value&lt;type&gt; name { *this, #name, init };</span></div>
</div><!-- fragment --><p>...so the above declaration would be <code>MAKE_VALUE_MEMBER (int, x, {});</code>. Once a <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> containing this declaration is instantiated, you can manipulate that value almost exactly the same as if it were an actual instance of the underlying type ("almost exactly" here covers edge cases like <code>sizeof</code> giving different results, and probably others that I haven't considered yet):</p>
<div class="fragment"><div class="line"><span class="comment">// after each of these lines, any property change callbacks watching </span></div>
<div class="line"><span class="comment">// `x` will be called. </span></div>
<div class="line">myObj.x = 20;</div>
<div class="line">--myObj.x;</div>
<div class="line">myObj.x *= -3;</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md22"></a>
VariantConverters</h2>
<p>By defining a template specialization of the <code>juce::VariantConverter</code> struct, you can store more complex value types by cleverly packing them inside one of the more interesting <code>var</code> variants that exist &mdash; in this example from the <code>cello</code> unit tests, we use the fact that an <code>Array</code> of <code>var</code>s is a <code>var</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>juce</div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>VariantConverter&lt;std::complex&lt;float&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> std::complex&lt;float&gt; fromVar (<span class="keyword">const</span> var&amp; v)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* array = v.getArray (); array != <span class="keyword">nullptr</span> &amp;&amp; array-&gt;size () == 2)</div>
<div class="line">            <span class="keywordflow">return</span> { array-&gt;getUnchecked (0), array-&gt;getUnchecked (1) };</div>
<div class="line">        jassertfalse;</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> var toVar (<span class="keyword">const</span> std::complex&lt;float&gt;&amp; val)</div>
<div class="line">    {</div>
<div class="line">        Array&lt;var&gt; array;</div>
<div class="line">        array.set (0, val.real ());</div>
<div class="line">        array.set (1, val.imag ());</div>
<div class="line">        <span class="keywordflow">return</span> { std::move (array) };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace juce</span></div>
</div><!-- fragment --><p>Then we define a class that has a single public Value member that contains a <code>std::complex&lt;float&gt;</code> &mdash; there's no additional work required to perform the conversions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ObjectWithConvertibleValue : <span class="keyword">public</span> <a class="code hl_class" href="classcello_1_1_object.html">cello::Object</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ObjectWithConvertibleValue ()</div>
<div class="line">    : cello::Object (<span class="stringliteral">&quot;convertible&quot;</span>, nullptr)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the `complexVal` member can be used as a `std::complex&lt;float&gt;`; the </span></div>
<div class="line">    <span class="comment">// round-tripping through a juce::var is completely hidden. </span></div>
<div class="line">    MAKE_VALUE_MEMBER (std::complex&lt;float&gt;, complexVal, {});</div>
<div class="line">};</div>
</div><!-- fragment --><p>Your code is then free to work with that value directly:</p>
<div class="fragment"><div class="line">ObjectWithConvertibleValue o;</div>
<div class="line">std::complex&lt;float&gt; orig { 2.f, 3.f };</div>
<div class="line">o.complexVal = orig;</div>
<div class="line"> </div>
<div class="line">std::complex&lt;float&gt; retrieved { o.complexVal };</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.real (), retrieved.real (), 0.001f);</div>
<div class="line">expectWithinAbsoluteError&lt;float&gt; (orig.imag (), retrieved.imag (), 0.001f);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Validator Functions</h2>
<p>If we're taking some inspiration from Python here, it's worth remembering that Python developers are in the practice of leaving all their class member variables public instead of hiding them behind a wall of privacy and forcing the usage of <code>getVariable()</code>/<code>setVariable()</code> methods to ensure the separation of interface from implementation&mdash;much of the time, there's no reason to require those accessor/mutator methods, and when there is an actual reason (for example, to ensure the maintenance of a class invariant), it's easy to switch over to using a property to manage access to the underlying data. Bertrand Meyer, creator of the Eiffel programming language refers to this as the "Uniform Access Principle," that _"...all services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation."_</p>
<p>Each <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> object may have <code>ValidatePropertyFn</code> lambdas assigned to it (where that lambda accepts a const reference to <code>T</code> and returns a <code>T</code> by value) that are (<code>onSet</code>) called before that value is stored into the underlying ValueTree or (<code>onGet</code>) called after retrieving the property from the ValueTree but before returning the value to calling code.</p>
<p>Your application can use this facility to modify the value (e.g. to keep it within a valid range), create an entirely new value, make changes to other properties of the ValueTree, create log entries, or anything else that you need to happen at these juncture points.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Caching values</h2>
<p>There will be times when a value stored in a ValueTree/Object needs to be used frequently enough that the overhead of re-fetching from the underlying tree and performing validation on it become problematic. The <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a>::&lt;T&gt;::Cached</code> class provides a simple mechanism to maintain a copy of a Value object that's automatically updated each time it changes.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Forcing Update Callbacks</h2>
<p>The normal behavior of ValueTrees is to only notify callback listeners of property changes when a value actually <em>changes</em>. In practice, it's frequently useful to ensure that any attempt to set a property results in notifications being sent even if setting it to its current value. This can be controlled on a per-value basis by calling that value's <code>forceUpdate (bool shouldForceUpdate)</code> method.</p>
<p>To simplify the common case where this behavior is only meant to be in force for a single update, we provide a utility class <code>ScopedForceUpdater</code> that sets the value to force sending updates when the class is constructed, and then clears the update logic when that updater object goes out of scope.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Excluding Listeners</h2>
<p>It's also common to want to send update callbacks to all listeners except one&mdash;for example, if I have a bit of code that's setting a value and that code is also listening to the value, there's no need to receive a callback; that code already knows what the new value is. The <code><a class="el" href="classcello_1_1_value.html" title="A class to abstract away the issues around storing and retrieving a value from a ValueTree....">cello::Value</a></code> class provides a method <code>void excludeListener (juce::ValueTree::Listener* listener)</code> for this purpose.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Objects</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Creation Patterns: Creating vs Wrapping</h2>
<p>Since our objects rely on separate ValueTree objects for their storage, we need to support two different mechanisms for creating instances:</p>
<ol type="1">
<li>If the ValueTree doesn't exist yet, we need to create one and initialize it for use.</li>
<li>When the value tree already exists, we need to 'wrap' it to access its storage and capabilities.</li>
</ol>
<p>The constructors of <code><a class="el" href="classcello_1_1_object.html">cello::Object</a></code> handle both these cases for us, using the logic outlined below:</p>
<ul>
<li><code>Object (const juce::String&amp; type, Object* state);</code> (preferred)</li>
<li><code>Object (const juce::String&amp; type, Object&amp; state);</code> (preferred)</li>
<li><code>Object (const juce::String&amp; type, juce::ValueTree tree);</code></li>
</ul>
<ol type="1">
<li>If the <code>state</code> or <code>tree</code> argument is of type <code>type</code>, wrap that inside the object being created.</li>
<li>If the <code>state</code> or <code>tree</code> arguments has a child of type <code>type</code>, wrap that child inside the object beng created.</li>
<li>Else, we create a new ValueTree of type <code>type</code> and initialize it as appropriate. If the <code>state</code> arg was not null (or the <code>tree</code> is valid), add this new tree as a child.</li>
</ol>
<p>It is sometimes useful to know whether a new Object was created or wrapped &mdash; for example, it might be an error in your application if a child that's expected to be present isn't.</p>
<p>You can test this at runtime using the method <code>Object::getCreationType()</code>, which will return either:</p><ul>
<li><code>Object::CreationType::initialized</code></li>
<li><code>Object::CreationType::wrapped</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
Creating/Finding Objects in a Hierarchy</h2>
<p>The <code>type</code> argument to an Object constructor can be richer than just a simple <code>juce::Identifier</code>; it's useful in an application to be able to pass around a single top-level context object and have individual objects within that hierarchy be able to find themselves.</p>
<p>Consider a common pattern where an application needs to have separate trees to collect persistent attributes that are saved and restored between app runs, and another that holds runtime values that are recreated each time the application runs. Rather than write procedural code to start at the root and find (or create) individual child objects that are expected, we can do the same thing declaratively using paths, like: <code>/persistent/object1/object2</code>, which would start at the root tree, then descend through children <code>persistent</code>, <code>object1</code>, and <code>object2</code>, creating any children that are not found.</p>
<p>Path elements are separated with forward slashes.</p>
<p>If the first character in a path string is <code>/</code>, the path is absolute starting at the root.</p>
<p>All other paths are relative to the Object that's passed into an Object constructor.</p>
<p>Path elements starting with a circumflex character <code>^</code> will search upward from the current path location to find an ancestor Object of a specified type, so <code>^grandpa</code> is read as "search upward in the hierarchy from the current path location until you find an object of type &lt;tt&gt;grandpa&lt;/tt&gt;.

A path element of &lt;tt&gt;..&lt;/tt&gt; operates as it does in file systems, navigating to the parent of the current path location, so &lt;tt&gt;../sibling&lt;/tt&gt; would find a sibling object of the current one, and &lt;tt&gt;../../uncle&lt;/tt&gt; will look for a sibling of the current object's parent. 

All other paths must be valid &lt;tt&gt;juce::Identifier&lt;/tt&gt;s, and search downward through child objects. 

Downward searches when instantiating &lt;tt&gt;cello::Object&lt;/tt&gt;s will create child trees (that will &lt;em&gt;not&lt;/em&gt; be initialized) as needed. 

Searches upward from an object will not be able to create interim object/trees. You can check the &lt;tt&gt;CreationType&lt;/tt&gt; after the constructor executes to make sure that you have a valid object before using it. You can test for existence before attempting creation by instantiating a &lt;tt&gt;cello::Path&lt;/tt&gt; object directly and using its &lt;tt&gt;findValueTree()&lt;/tt&gt; method with a search type of &lt;tt&gt;Query&lt;/tt&gt;; if that search returns an invalid &lt;tt&gt;juce::ValueTree&lt;/tt&gt;, you'll need to handle that case as appropriate, whether it's an error, or just triggers additional configuration/creation of the hierarchy before using it. 


@subsection autotoc_md30 Working with Children

ValueTrees can contain other ValueTrees as children, and it's important to keep in mind that there are two different modes for this containment:

* &lt;em&gt;Heterogeneous&lt;/em&gt; The parent tree is a data structure that contains other (tree) data structures. Access the children by specifying their type. The children are stored in a list, but the sequence is not significant.
* &lt;em&gt;Homogeneous&lt;/em&gt; The parent tree contains a list of child trees, typically but not necessarily of the same type. Access the children by their index or iterating through them. 

There's no mechanism to enforce this distinction&amp;mdash;if a list of different types makes sense in your application, there's a little more logic you'll need to write, but that's all. 

@subsubsection autotoc_md31 Adding Children

&lt;tt&gt;void append (Object* object);&lt;/tt&gt; adds the child to the end of this object's child list. 

&lt;tt&gt;void insert (Object* object, int index);&lt;/tt&gt; adds the child at a specific index in the list; if &lt;tt&gt;index&lt;/tt&gt; is out of range (less than zero or greater than the current number of children), the child will be appended to the list. 

@subsubsection autotoc_md32 Removing Children

To remove a child that's already wrapped in an Object, use 

@icode{cpp} 
 Object* remove (Object* object);
 @endicode 

 On success, this will return the same pointer you passed it; if that Object was not actually a child of this object, will return &lt;tt&gt;nullptr&lt;/tt&gt;. 

 To remove a child by its index: 

 @icode{cpp} 
juce::ValueTree remove (int index);
@endicode 

This will return the raw ValueTree used by that child on success, or an invalid ValueTree on failure. 

@subsubsection autotoc_md33 Finding Children

We provide an &lt;tt&gt;operator[]&lt;/tt&gt; to access children by their index:

@icode{cpp} 
juce::ValueTree operator[] (int index) const;
@endicode 

You can also iterate through an Object's children:

@icode{cpp} 
for (auto childTree: someObject)
{
    // work with the raw ValueTree here, maybe using it to instantiate an object...
}
@endicode 

@subsubsection autotoc_md34 Moving / Sorting Children

You can change the position of an individual child using the method

@icode{cpp} 
void move (int fromIndex, int toIndex);
@endicode 

...and sort all the children with the method: 

@icode{cpp} 
template &lt;typename Comparator&gt; 
void sort (Comparator&amp; comp, bool stableSort);
@endicode 

where &lt;tt&gt;Comparator&lt;/tt&gt; is an object that contains a method
@icode{cpp} 
int compareElements (const ValueTree&amp; first, const ValueTree&amp; second);
@endicode 

that returns 
* a value of &lt; 0 if the first comes before the second
* a value of 0 if the two objects are equivalent
* a value of &gt; 0 if the second comes before the first

The &lt;tt&gt;stableSort&lt;/tt&gt; argument specifies whether the sort algorithm should guarantee that equivalent children remain in their original order after the sort. 

After &lt;tt&gt;cello&lt;/tt&gt; release 1.1, you may wish to instead use the new database/query features for searching and sorting. 

@subsection autotoc_md35 Database / Query

Use the &lt;tt&gt;cello::Query&lt;/tt&gt; object to define a set of search and sort criteria to use to perform simple database-like operations. Instead of defining a query language, we've defined two function types that can be passed into a Query object to define its behavior at run time: 

@subsubsection autotoc_md36 Query::Predicate

@icode{cpp} 
    // query function, returns true if the tree it is passed should
    // be included in the result set.
    using Predicate = std::function&lt;bool (juce::ValueTree)&gt;;

    /**
     * @brief Append a filter predicate to the end of our list; these are
     * executed in the sequence they're added, and we stop testing at the first
     * filter that returns false.
     *
     * @param filter
     * @return Query&amp; reference to this so we can use the builder pattern.
     */
    Query&amp; addFilter (Predicate filter);
@endicode 

You can specify any number of predicate functions for a Query object to use; these functions accept a ValueTree as an argument and return a boolean to indicate whether this child tree should be included in the query search results. 

The search logic will execute these functions in the order they were added until encountering one that returns &lt;tt&gt;false&lt;/tt&gt;. If all of the query predicates return &lt;tt&gt;true&lt;/tt&gt;, a copy of this ValueTree will be added to the search results. 

If a query is run with no predicate functions defined, all children of the &lt;tt&gt;Object&lt;/tt&gt; being searched will be copied and added to the search results. 

@subsubsection autotoc_md37 Query::Comparison

@icode{cpp} 
    // comparison/sort function.
    // return 0 if the two trees should sort equally.
    // return -1 if left should come before right
    // return +1 if right should come before left.
    using Comparison = std::function&lt;int (const juce::ValueTree&amp;, const juce::ValueTree&amp;)&gt;;

    /**
     * @brief Add a comparison function to the list we use to sort a list
     * of children.
     *
     * @param sorter
     * @return Query&amp; so we can chain these calls together.
     */
    Query&amp; addComparison (Comparison sorter);
@endicode 

You can also specify comparison functions that will be used to sort the results list after a query is performed; if none are provided, the items in the search results will be in the same order they exist in the &lt;tt&gt;Object&lt;/tt&gt; being queried. 

@subsubsection autotoc_md38 Object::find

@icode{cpp} 
    /**
     * @brief Perform a query against the children of this Object, returning
     * a new ValueTree containing zero or more copies of child trees that
     * match the query, possibly sorted into a different order than they
     * exist in this tree.
     *
     * @param query Query object that defines the search/sort criteria
     * @param deep if true, also copy sub-items from object.
     * @return juce::ValueTree with search results.
     */
    juce::ValueTree find (const cello::Query&amp; query, bool deep = false);
@endicode 

@subsubsection autotoc_md39 Object::upsert and Object::upsertAll

These use a concept borrowed from the MongoDB NoSql database; an 'upsert` operation performs one of:
- Update a record in place if possible
- Otherwise, add (insert) a new record to the object. 

The main use case here would be to 
1. Perform a query to get a list of (copies of) items
2. Modify those copies in the result list
3. Perform an upsert to apply the changes back into the original data. 

For this to work, your items must be defined such that each has a unique key value that can be used to link the update tree with the original one to be updated. In the unit tests for this function, our &lt;tt&gt;Data&lt;/tt&gt; objects have an attribute &lt;tt&gt;key&lt;/tt&gt; that is populated with a monotonically incremented integer when created. In production code, it would be better to use something more unique, like a &lt;tt&gt;juce::Uuid&lt;/tt&gt;. 

@subsection autotoc_md40 Undo/Redo

Most ValueTree operations accept a pointer to a &lt;tt&gt;juce::UndoManager&lt;/tt&gt; object as an argument to make those operations undoable/redoable. &lt;tt&gt;cello::Object&lt;/tt&gt;s can maintain this manager for you: pass a pointer to &lt;tt&gt;UndoManager&lt;/tt&gt; to a &lt;tt&gt;cello::Object&lt;/tt&gt; using its &lt;tt&gt;setUndoManager&lt;/tt&gt; method, and that object and any child/descendant objects that are added to it will become undoable. 

The following undo/redo methods are available directly from &lt;tt&gt;cello::Object&lt;/tt&gt;: 

* &lt;tt&gt;bool canUndo () const;&lt;/tt&gt;
* &lt;tt&gt;bool undo ();&lt;/tt&gt;
* &lt;tt&gt;bool canRedo () const;&lt;/tt&gt;
* &lt;tt&gt;bool redo ();&lt;/tt&gt;
* &lt;tt&gt;void clearUndoHistory ();&lt;/tt&gt;

You can also retrieve a pointer to the UndoManager (using &lt;tt&gt;juce::UndoManager* getUndoManager()&lt;/tt&gt;) for any of its other operations that we don't expose directly.

@subsection autotoc_md41 Change Callbacks

The &lt;tt&gt;cello::Object&lt;/tt&gt; class defines a set of &lt;tt&gt;std::function&lt;/tt&gt;s that can be installed as callbacks to be executed when properties or children of an object are changed:

@subsubsection autotoc_md42 Property Changes

&lt;tt&gt;PropertyUpdateFn&lt;/tt&gt; signature: &lt;tt&gt;std::function\&lt;void(juce::Identifier)\&gt;&lt;/tt&gt;

You can register a callback for each named property of an object that will be executed when the value of that property is changed. You can also register a wildcard callback using the identifier of the object itself that will be called when an attribute changes but there was no specific handler for it. 

There are two Object methods to register these callbacks:

* &lt;tt&gt;void onPropertyChange (juce::Identifier id, PropertyUpdateFn callback)&lt;/tt&gt; &amp;mdash; pass in the identifier of the attribute to watch
* &lt;tt&gt;void onPropertyChange (const ValueBase\&amp; val, PropertyUpdateFn callback);&lt;/tt&gt; &amp;mdash; pass in a reference to the &lt;tt&gt;cello::Value&lt;/tt&gt; or &lt;tt&gt;cello::Object&lt;/tt&gt; to watch. 

If the &lt;tt&gt;Value&lt;/tt&gt; that you're watching is a public member of an &lt;tt&gt;Object&lt;/tt&gt;, you can also subscribe to its updates directly using the method &lt;tt&gt;Value\&lt;T\&gt;\::onPropertyUpdate (PropertyUpdateFn callback);&lt;/tt&gt;

@subsubsection autotoc_md43 Child Changes

Changes to children are broadcast using a &lt;tt&gt;ChildUpdateFn&lt;/tt&gt; callback that has the signature &lt;tt&gt;std::function\&lt;void (juce::ValueTree\&amp; child, int oldIndex, int newIndex)\&gt;;&lt;/tt&gt;

* &lt;tt&gt;onChildAdded&lt;/tt&gt; &amp;mdash; &lt;tt&gt;oldIndex&lt;/tt&gt; will be -1, &lt;tt&gt;newIndex&lt;/tt&gt; will be the index of the new child. 
* &lt;tt&gt;onChildRemoved&lt;/tt&gt; &amp;mdash; &lt;tt&gt;oldIndex&lt;/tt&gt; will be the index of the child that was removed, &lt;tt&gt;newIndex&lt;/tt&gt; will be -1.
* &lt;tt&gt;onChildMoved&lt;/tt&gt; &amp;mdash; &lt;tt&gt;oldIndex&lt;/tt&gt; and &lt;tt&gt;newIndex&lt;/tt&gt; are self-explanatory. 

@subsubsection autotoc_md44 Tree Changes

A &lt;tt&gt;SelfUpdateFn&lt;/tt&gt; callback with the signature &lt;tt&gt;std::function\&lt;void (void)\&gt;&lt;/tt&gt; will be called when:

* &lt;tt&gt;onParentChanged&lt;/tt&gt; &amp;mdash; this object has been adopted by a different parent tree.
* &lt;tt&gt;onTreeRedirected&lt;/tt&gt; &amp;mdash; the underlying value tree used by this object was replaced with a different one. 

@subsection autotoc_md45 "Pythonesque" access

Not everything can or should be done with the kind of compile-time API &lt;tt&gt;cello&lt;/tt&gt; was written to support. These methods take their names and inspriation from similar methods in the Python object model.

These methods do provide some level of type-safety and type-coercion using &lt;tt&gt;VariantConverter&lt;/tt&gt;s that our &lt;tt&gt;Value&lt;/tt&gt; types have.

* &lt;tt&gt;bool hasattr (const juce::Identifier\&amp; attr) const&lt;/tt&gt; tests an object to see if it has an attribute/property of the specified type (enabling what the Python world would call 'Look Before You Leap' programming)
* &lt;tt&gt;template \&lt;typename T\&gt; Object\&amp; setattr (const juce::Identifier\&amp; attr, const T\&amp; attrVal);&lt;/tt&gt; sets the value of the specified attribute in the object. We return a reference to the current Object so that multiple calls to this method can be chained together. 
* &lt;tt&gt;template \&lt;typename T\&gt; T getattr (const juce::Identifier\&amp; attr, const T\&amp; defaultVal) const&lt;/tt&gt; either returns the current value of the specified attribute, or a default value if it's not present. 

@subsection autotoc_md46 Persistence

&lt;tt&gt;cello::Object&lt;/tt&gt; instances can be persisted to or from disk in any of the three formats that ValueTrees support:
* text/XML
* (JUCE proprietary) binary
* binary, compressed with GZIP. 

To save a file, use the &lt;tt&gt;bool save (juce::File file, FileFormat format = FileFormat::xml) const&lt;/tt&gt; method, which will write out that tree and all its descendants into the specified file. 

Loading a file is a little more complex; we use a static method &lt;tt&gt;static juce::ValueTree load (juce::File file, FileFormat format = FileFormat::xml)&lt;/tt&gt; that attempts to load and return a ValueTree from the specified file; you should then pass that ValueTree (if valid) to the constructor of your application's root Object type and verify that the constructor was able to wrap the tree it was given, code like:

@icode{cpp} 

const juce::File filePath { "/path/to/my/file.xml" };
auto loadedTree { cello::Object::load(filePath) };

if (! loadedTree.isValid ())
{
    // failed to load the expected file. Maybe this is an error in your app?
    // if so, handle it! 
}

MyRootObject root { loadedTree };
if (root.getCreationType () == cello::Object::CreationType::initialized)
{
    // we didn't load successfully -- if this is an error in your app, 
    // handle it. 
}
// else, we've re-loaded -- carry on! 
@endicode 

@section autotoc_md47 Missing Pieces

There are parts of the &lt;tt&gt;juce::ValueTree&lt;/tt&gt; API that are not available through the &lt;tt&gt;cello&lt;/tt&gt; API; these may be added later, or you can use them directly by accessing the &lt;tt&gt;ValueTree&lt;/tt&gt; object that an &lt;tt&gt;Object&lt;/tt&gt; already owns. 

@section autotoc_md48 Unit Tests

There is a &lt;a href="<a href="https://github.com/bgporter/cello_test">https://github.com/bgporter/cello_test</a>" &gt;separate repo&lt;/a&gt; containing a small unit test runner; you can also add my &lt;a href="<a href="https://github.com/bgporter/testSuite">https://github.com/bgporter/testSuite</a>" &gt;testSuite&lt;/a&gt; JUCE module as a component in your application to execute the tests in your own app. 

@section autotoc_md49 Release Notes

See @ref "/github/workspace/CHANGELOG.md" "CHANGELOG"

@section autotoc_md50 License

@icode 
    Copyright (c) 2023 Brett g Porter
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
